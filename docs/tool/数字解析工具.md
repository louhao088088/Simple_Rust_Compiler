# 数字解析工具模块详解

## 数字字面量的复杂性

看似简单的数字`42`,在编译器眼中有很多细节:

1. **进制表示**:十进制`42`、十六进制`0x2A`、二进制`0b101010`、八进制`0o52`
2. **类型后缀**:`42i32`(有符号 32 位)、`42u32`(无符号 32 位)、`42isize`(指针大小)
3. **下划线分隔**:`1_000_000`(提高可读性,不影响值)
4. **溢出检测**:`5_000_000_000u32`超出 u32 范围,要报错

数字解析工具模块`tool/number.cpp`专门处理这些复杂性,将字符串形式的数字字面量转换为内部表示。

## Number 结构:值和类型的二元组

解析结果用`Number`结构表示:

```cpp
struct Number {
    long long value;    // 数值本身
    string Type;        // 类型:"i32", "u32", "isize", "usize", "anyint"
};
```

为什么返回类型字符串而不是`TypeKind`枚举?

**设计动机:解耦工具模块和类型系统**

工具模块是底层工具,不应依赖高层的类型系统。用字符串作为接口,让调用者根据需要转换:

```cpp
// 词法分析器调用
Number num = number_of_tokens("42i32", error_reporter);
// num.value = 42
// num.Type = "i32"

// 转换为类型枚举(在词法分析器中)
TypeKind kind = type_string_to_kind(num.Type);
```

这种设计让工具模块可以独立测试和复用,不依赖编译器的其他部分。

**anyint 类型的特殊性**

无类型后缀的字面量返回`"anyint"`:

```cpp
Number num = number_of_tokens("42", error_reporter);
// num.Type = "anyint"
```

这告诉类型系统:"这是某种整数,但具体类型待推导"。anyint 是类型检查器的概念,但工具模块需要识别并标记它。

## 多进制解析的统一框架

### 前缀识别和分发

不同进制有不同的前缀:

- 十六进制:`0x` → `0x2A`, `0xFF`
- 二进制:`0b` → `0b1010`, `0b1111`
- 八进制:`0o` → `0o52`, `0o777`
- 十进制:无前缀 → `42`, `1000`

解析流程:

```cpp
Number number_of_tokens(string token, ErrorReporter &error_reporter) {
    long long num = -1;  // -1表示"尚未初始化"

    if (token.length() > 2 && token[0] == '0' && token[1] == 'x') {
        // 十六进制解析
        return parse_hexadecimal(token, error_reporter);
    } else if (token.length() > 2 && token[0] == '0' && token[1] == 'b') {
        // 二进制解析
        return parse_binary(token, error_reporter);
    } else if (token.length() > 1 && token[0] == '0' && token[1] == 'o') {
        // 八进制解析
        return parse_octal(token, error_reporter);
    } else {
        // 十进制解析
        return parse_decimal(token, error_reporter);
    }
}
```

注意前缀检查的顺序:先检查长度,再检查字符,避免越界访问。

### 十六进制解析的字符映射

十六进制数字:`0-9`和`A-F`(或`a-f`),每个字符对应一个值:

```
'0' → 0,  '1' → 1, ..., '9' → 9
'A' → 10, 'B' → 11, ..., 'F' → 15
'a' → 10, 'b' → 11, ..., 'f' → 15
```

转换逻辑:

```cpp
// 在十六进制解析循环中
for (size_t i = 2; i < token.length(); i++) {  // 从索引2开始,跳过"0x"
    if (token[i] == '_') continue;  // 跳过下划线

    // 验证字符有效性
    bool is_hex_digit = (token[i] >= '0' && token[i] <= '9') ||
                        (token[i] >= 'a' && token[i] <= 'f') ||
                        (token[i] >= 'A' && token[i] <= 'F');

    if (!is_hex_digit) {
        // 可能是类型后缀,单独处理
        if (is_type_suffix(token, i)) {
            return parse_type_suffix(token, i, num, error_reporter);
        } else {
            error_reporter.report_error("Invalid number format");
            return {-1, "unknown"};
        }
    }

    // 计算数字值
    int digit_value;
    if (token[i] >= '0' && token[i] <= '9') {
        digit_value = token[i] - '0';           // '0'-'9' → 0-9
    } else if (token[i] >= 'a' && token[i] <= 'f') {
        digit_value = token[i] - 'a' + 10;      // 'a'-'f' → 10-15
    } else {
        digit_value = token[i] - 'A' + 10;      // 'A'-'F' → 10-15
    }

    // 累加到结果
    if (num == -1) num = 0;  // 第一次初始化
    num = num * 16 + digit_value;
}
```

**为何用-1 表示未初始化?**

这是一个编程技巧:用特殊值区分"未开始"和"值为 0"。如果直接初始化为 0:

```cpp
long long num = 0;
for (...) {
    num = num * 16 + digit;  // 第一次: 0 * 16 + digit = digit,正确
}
```

看起来也可以,但-1 的设计更明确:**遇到第一个有效数字时才初始化**。这在错误处理时有用:

```cpp
if (num < 0) {
    // 整个字符串没有有效数字
    error_reporter.report_error("Invalid number format");
}
```

### 二进制和八进制的类似逻辑

二进制解析:每位是 0 或 1,乘以 2:

```cpp
// 二进制循环
for (size_t i = 2; i < token.length(); i++) {
    if (token[i] == '_') continue;

    if (token[i] != '0' && token[i] != '1') {
        // 处理类型后缀或报错
        ...
    }

    if (num == -1) num = 0;
    num = num * 2 + (token[i] == '0' ? 0 : 1);
}
```

八进制解析:每位是 0-7,乘以 8:

```cpp
// 八进制循环
for (size_t i = 2; i < token.length(); i++) {
    if (token[i] == '_') continue;

    if (!(token[i] >= '0' && token[i] <= '7')) {
        // 处理类型后缀或报错
        ...
    }

    if (num == -1) num = 0;
    num = num * 8 + (token[i] - '0');
}
```

**统一的累加模式**:

所有进制都遵循同一公式:

```
result = result * base + digit_value
```

- 十进制:base = 10
- 十六进制:base = 16
- 二进制:base = 2
- 八进制:base = 8

这是**位置记数法**的数学本质:每一位的权重是`base^position`。

## 类型后缀的识别和验证

### 后缀的语法

Rust 支持的整数类型后缀:

- `i32`:有符号 32 位
- `u32`:无符号 32 位
- `isize`:有符号指针大小
- `usize`:无符号指针大小

语法规则:

- 后缀紧跟数字:`42i32`不是`42 i32`
- 后缀在数字末尾:`0x2Ai32`不是`0xi32A`
- 后缀大小写敏感:`i32`不是`I32`

识别逻辑:

```cpp
bool is_type_suffix(const string &token, size_t pos) {
    // 检查是否是'i'或'u'开头
    if (token[pos] != 'i' && token[pos] != 'u') {
        return false;
    }

    // 检查后面是"32"还是"size"
    size_t remaining = token.length() - pos;

    if (remaining == 3) {
        // 可能是i32或u32
        return token[pos + 1] == '3' && token[pos + 2] == '2';
    } else if (remaining == 5) {
        // 可能是isize或usize
        return token[pos + 1] == 's' &&
               token[pos + 2] == 'i' &&
               token[pos + 3] == 'z' &&
               token[pos + 4] == 'e';
    }

    return false;
}
```

**为何检查 remaining 而不是直接检查子串?**

这是边界安全的考虑:如果`token`在`pos`后不够长,直接访问`token[pos + 4]`会越界。先检查长度,确保安全。

### 溢出检测:类型约束的早期验证

不同的类型后缀对应不同的值范围:

- `i32`:`-2^31`到`2^31 - 1`(即-2147483648 到 2147483647)
- `u32`:`0`到`2^32 - 1`(即 0 到 4294967295)

解析时要检查值是否在范围内:

```cpp
if (token[i] == 'i') {  // i32或isize后缀
    if (num > 2147483647) {
        error_reporter.report_error("Integer overflow");
        return {-1, "unknown"};
    }

    if (token[i + 1] == 's') {
        return {num, "isize"};
    } else {
        return {num, "i32"};
    }
} else if (token[i] == 'u') {  // u32或usize后缀
    if (num > 4294967295) {
        error_reporter.report_error("Unsigned integer overflow");
        return {-1, "unknown"};
    }

    if (token[i + 1] == 's') {
        return {num, "usize"};
    } else {
        return {num, "u32"};
    }
}
```

**为何用`long long`表示可以检测 u32 溢出?**

`long long`在 C++中保证至少 64 位,足以表示 0 到 2^32-1。检查`num > 4294967295`就能捕获溢出。

但这有个**隐含的问题**:如果字面量超过`long long`的范围(2^63-1),累加时会溢出,检测失效:

```rust
let x = 100000000000000000000u32;  // 20个0,远超u32和long long
```

解析时`num`可能已经溢出为负数!正确的实现应该:

1. 每次累加前检查溢出:`num > (LLONG_MAX - digit) / base`
2. 或者用更大的类型(如`__int128`)
3. 或者用字符串直接比较

当前实现**未处理这种极端情况**,是个缺陷,但实际代码很少出现。

## 下划线分隔符的处理

Rust 允许在数字中插入下划线,提高可读性:

```rust
let million = 1_000_000;
let hex = 0xFF_AA_BB;
let binary = 0b1111_0000;
```

下划线**不影响值**,解析时跳过:

```cpp
for (size_t i = 0; i < token.length(); i++) {
    if (token[i] == '_') {
        continue;  // 直接跳过,不累加
    }

    // 处理数字字符
    ...
}
```

但要注意:**下划线不能在开头或单独出现**:

```rust
let x = _42;      // 错误:开头不能有下划线
let y = 4__2;     // 合法:连续下划线
let z = 42_;      // 合法:结尾下划线
```

当前实现的检查:

```cpp
// 十进制解析
if (token[0] == '_') {
    error_reporter.report_error("Invalid number format");
    return {-1, "unknown"};
}
```

但**未检查其他位置的下划线**,如`42_i32`(下划线在后缀前)。完整实现应该验证下划线的位置规则。

## 十进制解析的特殊性

十进制没有前缀,解析从索引 0 开始:

```cpp
// 十进制解析
for (size_t i = 0; i < token.length(); i++) {
    if (token[i] == '_') continue;

    if (!(token[i] >= '0' && token[i] <= '9')) {
        // 可能是类型后缀
        if (is_type_suffix(token, i)) {
            return parse_type_suffix(token, i, num, error_reporter);
        } else {
            error_reporter.report_error("Invalid number format");
            return {-1, "unknown"};
        }
    }

    if (num == -1) num = 0;
    num = num * 10 + (token[i] - '0');
}
```

**十进制和其他进制的统一**:除了 base 和起始索引,逻辑完全相同。理想的设计是**泛化解析函数**:

```cpp
Number parse_integer(const string &token, size_t start, int base,
                     ErrorReporter &error_reporter) {
    long long num = -1;

    for (size_t i = start; i < token.length(); i++) {
        if (token[i] == '_') continue;

        int digit_value = char_to_digit(token[i], base);
        if (digit_value < 0) {
            // 不是有效数字,可能是后缀
            if (is_type_suffix(token, i)) {
                return parse_type_suffix(token, i, num, error_reporter);
            } else {
                error_reporter.report_error("Invalid digit for base " + to_string(base));
                return {-1, "unknown"};
            }
        }

        if (num == -1) num = 0;
        num = num * base + digit_value;
    }

    return {num, "anyint"};
}

// 调用
if (token starts with "0x") {
    return parse_integer(token, 2, 16, error_reporter);
} else if (...) {
    ...
}
```

当前实现**复制了四份相似的代码**,违反了 DRY 原则(Don't Repeat Yourself)。这是可以重构的地方,但对于教学代码,重复的代码更直观。

## 错误处理的策略

数字解析可能遇到多种错误:

1. **非法字符**:`0x1G`(G 不是十六进制数字)
2. **溢出**:`10000000000i32`(超过 i32 范围)
3. **格式错误**:`_42`(下划线开头)、`0x`(没有数字)

错误处理策略:

- **立即报告**:遇到错误马上调用`error_reporter.report_error`
- **返回哨兵值**:`{-1, "unknown"}`表示解析失败
- **不抛异常**:用返回值表示失败,调用者检查

```cpp
Number result = number_of_tokens(token, error_reporter);
if (result.value == -1 || result.Type == "unknown") {
    // 解析失败,错误已报告,跳过这个token
    return;
}
```

**为何不抛异常?**

异常会打断控制流,导致编译器在第一个错误后就停止。返回哨兵值让编译器**继续解析**,收集更多错误,给用户完整的错误列表。

这是编译器错误处理的通用原则:**尽可能恢复并继续**。

## 与词法分析器的协作

数字解析工具是词法分析器的组件,词法分析器负责:

1. 识别数字字面量的边界(哪些字符属于这个 token)
2. 调用`number_of_tokens`解析
3. 根据返回的类型创建 Token

```cpp
// 在Lexer::next_token()中
if (isdigit(current_char) || (current_char == '0' && peek() == 'x')) {
    string num_str = scan_number();  // 扫描整个数字字符串

    Number num = number_of_tokens(num_str, error_reporter_);

    if (num.Type == "i32") {
        return Token(TokenType::INTEGER_LITERAL_I32, num.value, location);
    } else if (num.Type == "u32") {
        return Token(TokenType::INTEGER_LITERAL_U32, num.value, location);
    } else if (num.Type == "anyint") {
        return Token(TokenType::INTEGER_LITERAL, num.value, location);
    }
    // ... 其他类型
}
```

这种分离让**职责清晰**:

- 词法分析器:识别 token 边界,处理位置信息
- 数字解析器:解析数值和类型,验证格式

## 性能考量

数字解析的性能瓶颈:

1. **字符串遍历**:每个字符都要检查,O(n)时间
2. **字符分类**:大量的字符范围检查(`>= '0' && <= '9'`)
3. **乘法和加法**:每位都要算术运算

优化策略:

- **查表法**:用数组存储字符到数字的映射,O(1)查找

  ```cpp
  static const int hex_table[256] = {
      ['0'] = 0, ['1'] = 1, ..., ['9'] = 9,
      ['A'] = 10, ..., ['F'] = 15,
      ['a'] = 10, ..., ['f'] = 15,
      [其他] = -1
  };

  int digit = hex_table[(unsigned char)token[i]];
  if (digit < 0) { /* 非法字符 */ }
  ```

- **避免重复检查**:先验证整个字符串,再解析,不要每位都检查类型后缀

但对于编译器,数字解析不是性能瓶颈(相比语法分析和类型检查),当前实现的清晰性优先。

## 扩展性:支持更多类型

当前实现只支持 4 种类型后缀,Rust 完整支持:

- `i8`, `i16`, `i32`, `i64`, `i128`, `isize`
- `u8`, `u16`, `u32`, `u64`, `u128`, `usize`
- `f32`, `f64`(浮点数)

扩展的设计:

```cpp
struct TypeSuffix {
    string suffix;   // "i32", "u64", "f32"等
    long long max;   // 最大值(对于整数)
    bool is_signed;  // 是否有符号
    bool is_float;   // 是否浮点
};

static const TypeSuffix all_suffixes[] = {
    {"i8", 127, true, false},
    {"u8", 255, false, false},
    {"i32", 2147483647, true, false},
    {"u32", 4294967295, false, false},
    {"f32", 0, false, true},  // 浮点不检查范围
    // ...
};

// 解析时查表
const TypeSuffix* find_suffix(const string &token, size_t pos) {
    for (auto &suffix : all_suffixes) {
        if (token.compare(pos, suffix.suffix.length(), suffix.suffix) == 0) {
            return &suffix;
        }
    }
    return nullptr;
}
```

这让添加新类型变成**数据驱动**:只需在表中添加一行,不修改解析逻辑。

## 总结

数字解析工具模块是编译器的**基础设施**,处理数字字面量从字符串到内部表示的转换。

核心机制:

- **多进制支持**:通过前缀识别,统一的累加公式
- **类型后缀识别**:解析并验证类型标注
- **溢出检测**:根据类型检查值范围
- **下划线过滤**:跳过可读性分隔符
- **错误处理**:立即报告,返回哨兵值,继续解析

设计原则:

- **解耦**:用字符串类型接口,不依赖类型系统
- **清晰性优先**:重复代码换取直观性
- **鲁棒性**:检查边界,验证格式,处理错误

理解数字解析,就理解了编译器如何处理最基础的数据类型,如何在语法和语义之间建立桥梁,如何将人类可读的表示转换为机器可用的形式。
