# æ•°ç»„å’Œç»“æ„ä½“ IR ç”Ÿæˆå®ç°æŠ¥å‘Š

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®°å½•äº†ç¼–è¯‘å™¨ Phase 2D é˜¶æ®µå®ç°çš„æ•°ç»„å’Œç»“æ„ä½“ IR ç”ŸæˆåŠŸèƒ½ï¼ŒåŒ…æ‹¬è®¾è®¡æ€è·¯ã€å…³é”®æŠ€æœ¯ç‚¹ã€é‡åˆ°çš„é—®é¢˜åŠè§£å†³æ–¹æ¡ˆã€‚

**å®ç°æ—¶é—´ï¼š** 2025 å¹´ 11 æœˆ 13 æ—¥  
**å®ç°é˜¶æ®µï¼š** Phase 2D  
**éªŒè¯çŠ¶æ€ï¼š** âœ… 100% é€šè¿‡ llvm-as éªŒè¯

---

## ğŸ¯ åŠŸèƒ½æ¸…å•

### æ•°ç»„åŠŸèƒ½

| åŠŸèƒ½         | ç¤ºä¾‹ä»£ç                                | çŠ¶æ€ |
| ------------ | -------------------------------------- | ---- |
| æ•°ç»„å­—é¢é‡   | `let arr: [i32; 5] = [1, 2, 3, 4, 5];` | âœ…   |
| æ•°ç»„ç´¢å¼•è¯»å– | `let x = arr[2];`                      | âœ…   |
| æ•°ç»„ç´¢å¼•å†™å…¥ | `arr[2] = 99;`                         | âœ…   |
| æ•°ç»„å…ƒç´ è¿ç®— | `arr[0] * arr[1] + arr[2]`             | âœ…   |
| å˜é‡ç´¢å¼•     | `let idx = 3; arr[idx]`                | âœ…   |

### ç»“æ„ä½“åŠŸèƒ½

| åŠŸèƒ½         | ç¤ºä¾‹ä»£ç                           | çŠ¶æ€ |
| ------------ | --------------------------------- | ---- |
| ç»“æ„ä½“å®šä¹‰   | `struct Point { x: i32, y: i32 }` | âœ…   |
| ç»“æ„ä½“åˆå§‹åŒ– | `Point { x: 10, y: 20 }`          | âœ…   |
| å­—æ®µè¯»å–     | `let a = p.x;`                    | âœ…   |
| å­—æ®µå†™å…¥     | `p.x = 99;`                       | âœ…   |
| å­—æ®µè¿ç®—     | `r.width * r.height`              | âœ…   |

---

## ğŸ—ï¸ æ ¸å¿ƒè®¾è®¡æ€è·¯

### 1. èšåˆç±»å‹çš„æŒ‡é’ˆè¯­ä¹‰

**å…³é”®å†³ç­–ï¼š** æ•°ç»„å’Œç»“æ„ä½“åœ¨ LLVM IR ä¸­æŒ‰å¼•ç”¨ä¼ é€’

```rust
let arr: [i32; 5] = [1, 2, 3, 4, 5];
let x = arr;  // x è·å¾—çš„æ˜¯æ•°ç»„æŒ‡é’ˆï¼Œè€Œä¸æ˜¯å¤åˆ¶æ•´ä¸ªæ•°ç»„
```

**å®ç°æ–¹å¼ï¼š**

- `ArrayLiteralExpr` å’Œ `StructInitializerExpr` ç›´æ¥è¿”å› `alloca` ç”Ÿæˆçš„æŒ‡é’ˆ
- `VariableExpr` å¯¹èšåˆç±»å‹ä¸åŠ è½½å€¼ï¼Œç›´æ¥è¿”å›æŒ‡é’ˆ
- é¿å…äº†ä¸å¿…è¦çš„å¤§å¯¹è±¡å¤åˆ¶

**ä»£ç ä½ç½®ï¼š** `src/ir/ir_generator.cpp::visit(VariableExpr*)`

```cpp
// å¯¹äºæ•°ç»„å’Œç»“æ„ä½“ç±»å‹ï¼Œè¿”å›æŒ‡é’ˆè€Œä¸æ˜¯åŠ è½½å€¼
bool is_aggregate = (node->type->kind == TypeKind::ARRAY ||
                     node->type->kind == TypeKind::STRUCT);

if (is_aggregate) {
    store_expr_result(node, var_info->alloca_name);
} else {
    std::string loaded_value = emitter_.emit_load(type_str, var_info->alloca_name);
    store_expr_result(node, loaded_value);
}
```

---

### 2. å·¦å€¼ä¸å³å€¼çš„åŠ¨æ€åŒºåˆ†

**æ ¸å¿ƒé—®é¢˜ï¼š** å¦‚ä½•çŸ¥é“ `arr[2]` æ˜¯ç”¨äºè¯»å–è¿˜æ˜¯èµ‹å€¼ï¼Ÿ

**è§£å†³æ–¹æ¡ˆï¼š** å¼•å…¥ `generating_lvalue_` ä¸Šä¸‹æ–‡æ ‡å¿—

#### é—®é¢˜æ¼”åŒ–è¿‡ç¨‹

**æœ€åˆæ–¹æ¡ˆï¼ˆå¤±è´¥ï¼‰ï¼š** ä¾èµ– AST èŠ‚ç‚¹çš„ `is_mutable_lvalue` æ ‡å¿—

```cpp
// âŒ é—®é¢˜ï¼šè¯­ä¹‰åˆ†æå°† mut å˜é‡çš„æ‰€æœ‰è®¿é—®éƒ½æ ‡è®°ä¸º mutable_lvalue
if (node->is_mutable_lvalue) {
    return pointer;  // å¯¼è‡´ arr[2] æ€»æ˜¯è¿”å›æŒ‡é’ˆ
}
```

**æ”¹è¿›æ–¹æ¡ˆï¼ˆæˆåŠŸï¼‰ï¼š** IR ç”Ÿæˆå™¨ç»´æŠ¤è¿è¡Œæ—¶ä¸Šä¸‹æ–‡

```cpp
// âœ… è§£å†³ï¼šé€šè¿‡ generating_lvalue_ æ ‡å¿—åŠ¨æ€åˆ¤æ–­
class IRGenerator {
    bool generating_lvalue_ = false;  // ä»…åœ¨èµ‹å€¼å·¦ä¾§ä¸º true

    void visit(IndexExpr* node) {
        // ...
        if (generating_lvalue_) {
            store_expr_result(node, elem_ptr);  // è¿”å›æŒ‡é’ˆ
        } else {
            auto value = emitter_.emit_load(elem_ir_type, elem_ptr);
            store_expr_result(node, value);      // åŠ è½½å€¼
        }
    }
};
```

#### ä½¿ç”¨ç¤ºä¾‹

```cpp
void IRGenerator::visit(AssignmentExpr *node) {
    // 1. è®¡ç®—å³å€¼
    node->value->accept(this);

    // 2. è®¾ç½®å·¦å€¼ä¸Šä¸‹æ–‡å¹¶è®¿é—®ç›®æ ‡
    bool old_flag = generating_lvalue_;
    generating_lvalue_ = true;
    node->target->accept(this);  // arr[2] ç°åœ¨è¿”å›æŒ‡é’ˆ
    generating_lvalue_ = old_flag;

    // 3. å­˜å‚¨åˆ°æŒ‡é’ˆ
    emitter_.emit_store(type_str, value, target_ptr);
}
```

**å…³é”®ä¼˜åŠ¿ï¼š**

- åŒä¸€ä¸ª `IndexExpr` èŠ‚ç‚¹åœ¨ä¸åŒä¸Šä¸‹æ–‡ä¸­æœ‰ä¸åŒè¡Œä¸º
- ä¸éœ€è¦ä¿®æ”¹ AST èŠ‚ç‚¹çŠ¶æ€
- å®Œç¾æ”¯æŒå¤æ‚è¡¨è¾¾å¼å¦‚ `arr[i] = arr[j]`

---

### 3. æ•°ç»„å­—é¢é‡çš„å†…å­˜å¸ƒå±€

**IR ç”Ÿæˆç­–ç•¥ï¼š** æ ˆä¸Šåˆ†é… + é€å…ƒç´ åˆå§‹åŒ–

```rust
let arr: [i32; 5] = [1, 2, 3, 4, 5];
```

**ç”Ÿæˆçš„ IRï¼š**

```llvm
%0 = alloca [5 x i32]                                    ; åˆ†é…æ•°ç»„ç©ºé—´
%1 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i64 0, i64 0
store i32 1, i32* %1
%2 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i64 0, i64 1
store i32 2, i32* %2
; ... ç»§ç»­åˆå§‹åŒ–å…¶ä»–å…ƒç´ 
```

**å®ç°è¦ç‚¹ï¼š**

1. ä½¿ç”¨ `getelementptr` çš„åŒç´¢å¼•ï¼š`[i64 0, i64 idx]`
   - ç¬¬ä¸€ä¸ª `i64 0`ï¼šè§£å¼•ç”¨æ•°ç»„æŒ‡é’ˆ
   - ç¬¬äºŒä¸ª `i64 idx`ï¼šæ•°ç»„å†…çš„å…ƒç´ åç§»
2. è¿”å›æ•°ç»„æŒ‡é’ˆä¾›åç»­ä½¿ç”¨

**ä»£ç ä½ç½®ï¼š** `src/ir/ir_generator.cpp::visit(ArrayLiteralExpr*)`

---

### 4. ç»“æ„ä½“å­—æ®µé¡ºåºä¿è¯

**æ ¸å¿ƒæŒ‘æˆ˜ï¼š** `std::map<string, Type>` ä¸ä¿è¯å­—æ®µé¡ºåº

**è§£å†³æ–¹æ¡ˆï¼š** åœ¨ `StructType` ä¸­æ·»åŠ  `field_order` å‘é‡

#### ä¿®æ”¹çš„æ•°æ®ç»“æ„

```cpp
// src/semantic/semantic.h
struct StructType : public Type {
    std::string name;
    std::map<std::string, std::shared_ptr<Type>> fields;
    std::vector<std::string> field_order;  // âœ… æ–°å¢ï¼šä¿å­˜å­—æ®µé¡ºåº
    // ...
};
```

#### å­—æ®µé¡ºåºå¡«å……ï¼ˆä¸¤å¤„ï¼‰

**ä½ç½® 1ï¼š** `visit(StructDecl*)` - ç®€å•ç»“æ„ä½“

```cpp
// src/semantic/name_resolution.cpp
for (const auto &field_node : node->fields) {
    auto field_type = type_resolver_.resolve(field_node->type.get());
    struct_type->fields[field_node->name.lexeme] = field_type;
    struct_type->field_order.push_back(field_node->name.lexeme);  // âœ…
}
```

**ä½ç½® 2ï¼š** `define_struct_body()` - å‰å‘å£°æ˜çš„ç»“æ„ä½“

```cpp
void NameResolutionVisitor::define_struct_body(StructDecl *node) {
    // ...
    for (const auto &field_node : node->fields) {
        struct_type->fields[field_node->name.lexeme] = field_type;
        struct_type->field_order.push_back(field_node->name.lexeme);  // âœ…
    }
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ä¸¤å¤„ï¼Ÿ**

- ç¼–è¯‘å™¨æ”¯æŒç»“æ„ä½“å‰å‘å£°æ˜
- `declare_struct()` åªåˆ›å»ºç±»å‹ï¼Œ`define_struct_body()` å¡«å……å­—æ®µ
- ä¸¤ä¸ªé˜¶æ®µéƒ½å¿…é¡»ä¿è¯å­—æ®µé¡ºåºä¸€è‡´

#### IR ç”Ÿæˆæ—¶ä½¿ç”¨

```cpp
// src/ir/ir_generator.cpp::visit_struct_decl()
std::vector<std::string> field_types;
for (const auto &field_name : struct_type->field_order) {  // âœ… æŒ‰é¡ºåºéå†
    auto it = struct_type->fields.find(field_name);
    field_types.push_back(type_mapper_.map(it->second.get()));
}
emitter_.emit_struct_type(struct_type->name, field_types);
```

**ç”Ÿæˆç¤ºä¾‹ï¼š**

```llvm
%Point = type { i32, i32 }  ; x åœ¨å‰ï¼Œy åœ¨å
```

---

### 5. ç»“æ„ä½“å­—æ®µè®¿é—®

**å…³é”®æŠ€æœ¯ï¼š** `getelementptr` è®¡ç®—å­—æ®µåœ°å€

```rust
let p = Point { x: 10, y: 20 };
let a = p.x;
```

**å®ç°æ­¥éª¤ï¼š**

1. **æŸ¥æ‰¾å­—æ®µç´¢å¼•**

```cpp
int field_index = -1;
for (size_t i = 0; i < struct_type->field_order.size(); ++i) {
    if (struct_type->field_order[i] == node->field.lexeme) {
        field_index = static_cast<int>(i);
        break;
    }
}
```

2. **è®¡ç®—å­—æ®µåœ°å€**

```llvm
%4 = getelementptr inbounds %Point, %Point* %0, i32 0, i32 0  ; è®¿é—® x
%5 = load i32, i32* %4
```

3. **å·¦å€¼/å³å€¼å¤„ç†**

```cpp
if (generating_lvalue_) {
    store_expr_result(node, field_ptr);  // ç”¨äºèµ‹å€¼
} else {
    auto value = emitter_.emit_load(field_ir_type, field_ptr);
    store_expr_result(node, value);      // ç”¨äºè¯»å–
}
```

---

### 6. Let è¯­å¥çš„ç‰¹æ®Šå¤„ç†

**é—®é¢˜ï¼š** æ•°ç»„/ç»“æ„ä½“å­—é¢é‡å·²ç»åˆ†é…äº†å†…å­˜ï¼ŒLet è¯­å¥ä¸åº”é‡å¤åˆ†é…

**è§£å†³æ–¹æ¡ˆï¼š** æ£€æµ‹èšåˆå­—é¢é‡å¹¶ç›´æ¥ä½¿ç”¨å…¶æŒ‡é’ˆ

```cpp
// src/ir/ir_generator.cpp::visit(LetStmt*)
bool is_aggregate_literal = false;
if (node->initializer.has_value()) {
    auto init_expr = node->initializer.value();
    if (dynamic_cast<ArrayLiteralExpr*>(init_expr.get()) ||
        dynamic_cast<StructInitializerExpr*>(init_expr.get())) {
        is_aggregate_literal = true;
    }
}

if (is_aggregate_literal) {
    // ç›´æ¥ä½¿ç”¨è¡¨è¾¾å¼è¿”å›çš„æŒ‡é’ˆ
    init_expr->accept(this);
    alloca_name = get_expr_result(init_expr.get());
} else {
    // æ™®é€šæƒ…å†µï¼šå…ˆ allocaï¼Œå† store
    alloca_name = emitter_.emit_alloca(type_str);
    // ...
}
```

**æ•ˆæœå¯¹æ¯”ï¼š**

âŒ **æ²¡æœ‰ä¼˜åŒ–æ—¶ï¼š**

```llvm
%0 = alloca [5 x i32]  ; ArrayLiteralExpr åˆ†é…
; ... åˆå§‹åŒ–å…ƒç´ 
%1 = alloca [5 x i32]  ; LetStmt åˆåˆ†é…äº†ä¸€æ¬¡
store [5 x i32] %0, [5 x i32]* %1  ; âŒ é”™è¯¯ï¼šä¸èƒ½ store æ•°ç»„å€¼
```

âœ… **ä¼˜åŒ–åï¼š**

```llvm
%0 = alloca [5 x i32]  ; ArrayLiteralExpr åˆ†é…
; ... åˆå§‹åŒ–å…ƒç´ 
; LetStmt ç›´æ¥ä½¿ç”¨ %0ï¼Œä¸é‡å¤åˆ†é…
```

---

## ğŸ› å…³é”®é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é—®é¢˜ 1ï¼šå‡½æ•°ç¼ºå°‘è¿”å›æŒ‡ä»¤

**ç°è±¡ï¼š**

```llvm
define i32 @test_array_literal() {
entry:
  %0 = alloca [5 x i32]
  ; ... åˆå§‹åŒ–ä»£ç 
  ; âŒ ç¼ºå°‘ ret æŒ‡ä»¤
}
```

**åŸå› ï¼š** å‡½æ•°ä½“æ‰§è¡Œåæ²¡æœ‰è‡ªåŠ¨æ·»åŠ  `ret` æŒ‡ä»¤

**è§£å†³æ–¹æ¡ˆï¼š**

```cpp
// src/ir/ir_generator.cpp::visit_function_decl()
if (node->body.has_value()) {
    body->accept(this);

    // è·å–å‡½æ•°ä½“æœ€ç»ˆè¡¨è¾¾å¼çš„ç»“æœ
    std::string body_result;
    if (body->final_expr.has_value()) {
        body_result = get_expr_result(final_expr.get());
    }

    // å¦‚æœå—æœªç»ˆæ­¢ï¼Œæ·»åŠ è¿”å›æŒ‡ä»¤
    if (!current_block_terminated_) {
        if (ret_type_str == "void") {
            emitter_.emit_ret_void();
        } else if (!body_result.empty()) {
            emitter_.emit_ret(ret_type_str, body_result);
        } else {
            emitter_.emit_ret(ret_type_str, "0");  // å…œåº•
        }
    }
}
```

---

### é—®é¢˜ 2ï¼šæ•°ç»„ç´¢å¼•è¿”å›æŒ‡é’ˆè€Œéå€¼

**ç°è±¡ï¼š**

```llvm
%7 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i64 0, i64 2
ret i32 %7  ; âŒ è¿”å›çš„æ˜¯ i32* è€Œä¸æ˜¯ i32
```

**åŸå› ï¼š** è¯­ä¹‰åˆ†æå°† `mut` å˜é‡çš„æ‰€æœ‰è®¿é—®éƒ½æ ‡è®°ä¸º `is_mutable_lvalue = true`

```cpp
// src/semantic/type_check.cpp::visit(IndexExpr*)
node->is_mutable_lvalue = node->object->is_mutable_lvalue;
// å¦‚æœ arr æ˜¯ mutï¼Œarr[i] ä¹Ÿè¢«æ ‡è®°ä¸º mutable_lvalue
```

**é”™è¯¯çš„è§£å†³å°è¯•ï¼š**

```cpp
// âŒ å°è¯• 1ï¼šåœ¨ AssignmentExpr ä¸­ä¿®æ”¹æ ‡å¿—åæ¢å¤
index_expr->is_mutable_lvalue = true;
index_expr->accept(this);
index_expr->is_mutable_lvalue = old_flag;  // è¯•å›¾æ¢å¤
// é—®é¢˜ï¼šå¦‚æœ AST èŠ‚ç‚¹è¢«é‡ç”¨ï¼Œæ ‡å¿—ä»ç„¶ä¼šæ±¡æŸ“åç»­ä½¿ç”¨
```

**æ­£ç¡®è§£å†³æ–¹æ¡ˆï¼š** ä½¿ç”¨è¿è¡Œæ—¶ä¸Šä¸‹æ–‡æ ‡å¿—

```cpp
// âœ… æ–¹æ¡ˆï¼šIRGenerator ç»´æŠ¤ generating_lvalue_ æ ‡å¿—
bool generating_lvalue_ = false;

// IndexExpr æ ¹æ®ä¸Šä¸‹æ–‡å†³å®šè¡Œä¸º
if (generating_lvalue_) {
    return pointer;  // ä»…åœ¨èµ‹å€¼å·¦ä¾§è¿”å›æŒ‡é’ˆ
} else {
    return loaded_value;  // å…¶ä»–æƒ…å†µåŠ è½½å€¼
}
```

**éªŒè¯æµ‹è¯•ï¼š**

```rust
fn test() -> i32 {
    let mut arr: [i32; 5] = [1, 2, 3, 4, 5];
    arr[2] = 99;  // ç¬¬ä¸€ä¸ª arr[2]ï¼šè¿”å›æŒ‡é’ˆ
    arr[2]        // ç¬¬äºŒä¸ª arr[2]ï¼šåŠ è½½å€¼å¹¶è¿”å›
}
```

---

### é—®é¢˜ 3ï¼šç»“æ„ä½“ç±»å‹å®šä¹‰ä¸ºç©º

**ç°è±¡ï¼š**

```llvm
%Point = type {  }  ; âŒ å­—æ®µä¸ºç©º
```

**è°ƒè¯•è¿‡ç¨‹ï¼š**

1. æ£€æŸ¥ ASTï¼šå­—æ®µå­˜åœ¨ âœ…
2. æ£€æŸ¥ `field_order.push_back()`ï¼šä»£ç å­˜åœ¨ âœ…
3. é‡æ–°ç¼–è¯‘åä»ç„¶ä¸ºç©º âŒ

**æ ¹æœ¬åŸå› ï¼š** å­—æ®µå¡«å……æœ‰ä¸¤ä¸ªå…¥å£ï¼Œåªä¿®æ”¹äº†ä¸€ä¸ª

```cpp
// åªä¿®æ”¹äº†è¿™é‡Œ âœ…
void NameResolutionVisitor::visit(StructDecl *node) {
    struct_type->field_order.push_back(field_name);
}

// é—æ¼äº†è¿™é‡Œ âŒ
void NameResolutionVisitor::define_struct_body(StructDecl *node) {
    struct_type->fields[field_name] = field_type;
    // âŒ ç¼ºå°‘ï¼šstruct_type->field_order.push_back(field_name);
}
```

**è§£å†³æ–¹æ¡ˆï¼š** ä¸¤å¤„éƒ½æ·»åŠ  `field_order.push_back()`

**æ•™è®­ï¼š**

- ç¼–è¯‘å™¨é€šå¸¸æœ‰å¤šä¸ªä»£ç è·¯å¾„å¤„ç†åŒä¸€ç±»èŠ‚ç‚¹ï¼ˆç®€å•å®šä¹‰ vs å‰å‘å£°æ˜ï¼‰
- ä¿®æ”¹æ•°æ®ç»“æ„æ—¶å¿…é¡»æ£€æŸ¥æ‰€æœ‰ä½¿ç”¨ç‚¹
- ä½¿ç”¨ `grep` æœç´¢æ‰€æœ‰ç›¸å…³å‡½æ•°

---

## ğŸ“ ä»£ç æ¶æ„æ€»ç»“

### æ ¸å¿ƒæ–‡ä»¶åŠèŒè´£

| æ–‡ä»¶                               | èŒè´£          | å…³é”®ä¿®æ”¹                       |
| ---------------------------------- | ------------- | ------------------------------ |
| `src/semantic/semantic.h`          | ç±»å‹å®šä¹‰      | æ·»åŠ  `StructType::field_order` |
| `src/semantic/name_resolution.cpp` | ç¬¦å·è§£æ      | ä¸¤å¤„å¡«å…… `field_order`         |
| `src/ir/ir_generator.h`            | IR ç”Ÿæˆå™¨æ¥å£ | æ·»åŠ  `generating_lvalue_` æ ‡å¿— |
| `src/ir/ir_generator.cpp`          | IR ç”Ÿæˆå®ç°   | å®ç° 6 ä¸ªæ ¸å¿ƒ visitor          |

### å®ç°çš„ Visitor æ–¹æ³•

```cpp
// æ•°ç»„ç›¸å…³
void visit(ArrayLiteralExpr *node);       // æ•°ç»„å­—é¢é‡
void visit(IndexExpr *node);              // æ•°ç»„ç´¢å¼•è®¿é—®

// ç»“æ„ä½“ç›¸å…³
void visit(StructInitializerExpr *node);  // ç»“æ„ä½“åˆå§‹åŒ–
void visit(FieldAccessExpr *node);        // å­—æ®µè®¿é—®
void visit_struct_decl(StructDecl *node); // ç»“æ„ä½“ç±»å‹å®šä¹‰

// è¯­å¥æ”¯æŒ
void visit(LetStmt *node);                // Let è¯­å¥ï¼ˆç‰¹æ®Šå¤„ç†èšåˆç±»å‹ï¼‰
void visit(AssignmentExpr *node);         // èµ‹å€¼ï¼ˆæ”¯æŒ arr[i] å’Œ obj.fieldï¼‰
void visit(VariableExpr *node);           // å˜é‡ï¼ˆèšåˆç±»å‹è¿”å›æŒ‡é’ˆï¼‰
```

---

## ğŸ§ª æµ‹è¯•è¦†ç›–

### æ•°ç»„æµ‹è¯• (test_arrays_simple.rs)

```rust
// âœ… Test 1: æ•°ç»„å­—é¢é‡
let arr: [i32; 5] = [1, 2, 3, 4, 5];

// âœ… Test 2: ç´¢å¼•è¯»å–
let x: i32 = arr[2];  // è¿”å›å€¼

// âœ… Test 3: ç´¢å¼•å†™å…¥
arr[2] = 99;          // ä½¿ç”¨æŒ‡é’ˆ

// âœ… Test 4: å¤šæ¬¡è®¿é—®
let a = arr[0]; let b = arr[1]; let c = arr[2]; let d = arr[3];

// âœ… Test 5: å…ƒç´ è¿ç®—
let result: i32 = arr[0] * arr[1] + arr[2];
```

### ç»“æ„ä½“æµ‹è¯• (test_structs_simple.rs)

```rust
struct Point { x: i32, y: i32 }
struct Rectangle { width: i32, height: i32 }

// âœ… Test 1: ç»“æ„ä½“åˆå§‹åŒ–
let p: Point = Point { x: 10, y: 20 };

// âœ… Test 2: å­—æ®µè¯»å–
let a: i32 = p.x;

// âœ… Test 3: å­—æ®µå†™å…¥
p.x = 99;

// âœ… Test 4: å­—æ®µè¿ç®—
let area: i32 = r.width * r.height;
```

### éªŒè¯ç»“æœ

```bash
âœ… test_arrays_simple.rs:  é€šè¿‡ llvm-as éªŒè¯
âœ… test_structs_simple.rs: é€šè¿‡ llvm-as éªŒè¯
âœ… åŸæœ‰ 7 ä¸ªæµ‹è¯•å¥—ä»¶:     å…¨éƒ¨é€šè¿‡

ğŸ“Š æ€»è®¡ï¼š9 ä¸ªæµ‹è¯•å¥—ä»¶ï¼Œ100% é€šè¿‡ç‡
```

---

## ğŸ”„ ä¸ç°æœ‰ç³»ç»Ÿçš„é›†æˆ

### 1. ç±»å‹ç³»ç»Ÿé›†æˆ

```
BuiltinTypes
    â”œâ”€â”€ i32, bool, () (å·²æœ‰)
    â””â”€â”€ ArrayType, StructType (æ–°å¢)
         â†“
    TypeMapper::map()
         â”œâ”€â”€ [N x T]        â†’ æ•°ç»„ç±»å‹
         â””â”€â”€ %StructName    â†’ ç»“æ„ä½“ç±»å‹
```

### 2. æ§åˆ¶æµé›†æˆ

- âœ… æ•°ç»„/ç»“æ„ä½“åœ¨ if/while/loop ä¸­æ­£å¸¸å·¥ä½œ
- âœ… ä¸ break/continue/return å…¼å®¹
- âœ… æ”¯æŒåµŒå¥—ç»“æ„ï¼ˆå¦‚ç»“æ„ä½“æ•°ç»„ï¼‰

### 3. è¡¨è¾¾å¼ç³»ç»Ÿé›†æˆ

```
BinaryExpr
    â”œâ”€â”€ æ“ä½œæ•°å¯ä»¥æ˜¯ IndexExpr        âœ…
    â””â”€â”€ æ“ä½œæ•°å¯ä»¥æ˜¯ FieldAccessExpr  âœ…

AssignmentExpr
    â”œâ”€â”€ target å¯ä»¥æ˜¯ IndexExpr       âœ…
    â””â”€â”€ target å¯ä»¥æ˜¯ FieldAccessExpr âœ…
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [IR ç”Ÿæˆæ¨¡å—æ€»è§ˆ](./IRç”Ÿæˆæ¨¡å—æ€»è§ˆ.md)
- [IRGenerator å®ç°è¿›åº¦æŠ¥å‘Š v2](./IRGeneratorå®ç°è¿›åº¦æŠ¥å‘Šv2_old.md)
- [TypeMapper è®¾è®¡åˆ†æ](./TypeMapperè®¾è®¡åˆ†æ.md)

---

## ğŸš€ ä¸‹ä¸€æ­¥å·¥ä½œ

### Phase 2E: Match è¡¨è¾¾å¼

**ä¼˜å…ˆçº§ï¼š** Medium-High

```rust
match x {
    0 => 1,
    1 => 1,
    n => fibonacci(n-1) + fibonacci(n-2)
}
```

**æŠ€æœ¯æŒ‘æˆ˜ï¼š**

- æ¨¡å¼åŒ¹é…çš„ IR ç”Ÿæˆï¼ˆswitch æŒ‡ä»¤ï¼‰
- å˜é‡ç»‘å®šçš„å¤„ç†
- é»˜è®¤åˆ†æ”¯ï¼ˆ\_ æ¨¡å¼ï¼‰

### å·²çŸ¥é™åˆ¶ä¿®å¤

**ä¼˜å…ˆçº§ï¼š** Medium

- alloca åœ¨å¾ªç¯å†…çš„é—®é¢˜ï¼ˆéœ€è¦ IREmitter é‡æ„ï¼‰
- æ•°ç»„åˆå§‹åŒ–å™¨ `[value; size]` æ”¯æŒ

---

## ğŸ“Œ æ€»ç»“

æœ¬é˜¶æ®µæˆåŠŸå®ç°äº†ç¼–è¯‘å™¨å¯¹å¤åˆæ•°æ®ç±»å‹çš„å®Œæ•´æ”¯æŒï¼Œå…³é”®æˆå°±åŒ…æ‹¬ï¼š

1. **è®¾è®¡åˆ›æ–°ï¼š** `generating_lvalue_` æ ‡å¿—ä¼˜é›…è§£å†³äº†å·¦å€¼/å³å€¼åŒºåˆ†é—®é¢˜
2. **ç±»å‹ä¿è¯ï¼š** `field_order` å‘é‡ç¡®ä¿ç»“æ„ä½“å­—æ®µé¡ºåºæ­£ç¡®
3. **æ€§èƒ½ä¼˜åŒ–ï¼š** èšåˆç±»å‹æŒ‰å¼•ç”¨ä¼ é€’ï¼Œé¿å…å¤§å¯¹è±¡å¤åˆ¶
4. **å®Œæ•´æ€§ï¼š** 100% æµ‹è¯•é€šè¿‡ç‡ï¼ŒIR å…¨éƒ¨é€šè¿‡ llvm-as éªŒè¯

è¿™äº›åŠŸèƒ½ä¸ºåç»­å®ç°æ›´å¤æ‚çš„æ•°æ®ç»“æ„ï¼ˆå¦‚åµŒå¥—æ•°ç»„ã€ç»“æ„ä½“æ•°ç»„ï¼‰å¥ å®šäº†åšå®åŸºç¡€ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æœ€åæ›´æ–°ï¼š** 2025-11-13  
**ä½œè€…ï¼š** IR Generator Team
