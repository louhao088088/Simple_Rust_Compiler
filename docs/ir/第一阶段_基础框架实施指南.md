# ç¬¬ä¸€é˜¶æ®µ:åŸºç¡€æ¡†æ¶å®æ–½æŒ‡å—

## æ ¸å¿ƒç†å¿µ:æ‰‹åŠ¨ç”Ÿæˆ LLVM IR æ–‡æœ¬

**å…³é”®å†³ç­–**: ä¸ä½¿ç”¨ LLVM C++ API,è€Œæ˜¯ç›´æ¥ç”Ÿæˆ LLVM IR æ–‡æœ¬æ ¼å¼(.ll æ–‡ä»¶)

**ä¸ºä»€ä¹ˆè¿™æ ·åš?**

- å®Œå…¨ç†è§£ LLVM IR çš„è¯­æ³•å’Œç»“æ„
- ä¸ä¾èµ– LLVM åº“,ç®€åŒ–æ„å»ºç³»ç»Ÿ
- æ›´å®¹æ˜“è°ƒè¯•(ç›´æ¥æŸ¥çœ‹ç”Ÿæˆçš„æ–‡æœ¬)
- æ•™è‚²ä»·å€¼æœ€å¤§åŒ–

**ç”Ÿæˆç­–ç•¥**:

- æ‰€æœ‰ IR æŒ‡ä»¤éƒ½æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥
- ä½¿ç”¨`std::stringstream`æˆ–`std::ofstream`è¾“å‡º
- æ‰‹åŠ¨ç®¡ç†ä¸´æ—¶å˜é‡å‘½å(å¦‚%0, %1, %2)
- æ‰‹åŠ¨ç®¡ç†åŸºæœ¬å—æ ‡ç­¾(å¦‚ label1, label2)

## é˜¶æ®µç›®æ ‡

æ­å»º IR ç”Ÿæˆæ¨¡å—çš„åŸºæœ¬æ¶æ„,èƒ½å¤Ÿ:

- ç›´æ¥è¾“å‡º LLVM IR æ–‡æœ¬åˆ°.ll æ–‡ä»¶
- è½¬æ¢åŸºæœ¬çš„ Rust ç±»å‹åˆ° LLVM IR ç±»å‹è¡¨ç¤º
- ç®¡ç†ä¸´æ—¶å˜é‡å’Œæ ‡ç­¾çš„å‘½å
- ç®¡ç†å˜é‡ä½œç”¨åŸŸ
- è¾“å‡ºå¯ä»¥è¢« llvm-as éªŒè¯çš„ IR æ–‡æœ¬

**é¢„æœŸæ—¶é—´**: 1-2 å‘¨
**é‡Œç¨‹ç¢‘**: èƒ½ç”Ÿæˆä¸€ä¸ªç©ºçš„ä½†åˆæ³•çš„ LLVM IR æ–‡æœ¬æ–‡ä»¶

---

## å®æ–½æ­¥éª¤è¯¦è§£

### æ­¥éª¤ 1: åˆ›å»ºç›®å½•ç»“æ„å’ŒåŸºç¡€æ–‡ä»¶ (30 åˆ†é’Ÿ)

#### 1.1 åˆ›å»ºç›®å½•

```bash
cd /home/louhao/compiler
mkdir -p src/ir
```

#### 1.2 åˆ›å»ºæ–‡ä»¶éª¨æ¶

éœ€è¦åˆ›å»ºä»¥ä¸‹æ–‡ä»¶:

```
src/ir/
  â”œâ”€â”€ ir_emitter.h         # IRæ–‡æœ¬è¾“å‡ºå™¨(æ ¸å¿ƒ)
  â”œâ”€â”€ ir_emitter.cpp
  â”œâ”€â”€ type_mapper.h        # Rustç±»å‹åˆ°IRç±»å‹å­—ç¬¦ä¸²æ˜ å°„
  â”œâ”€â”€ type_mapper.cpp
  â”œâ”€â”€ value_manager.h      # å˜é‡å’Œä¸´æ—¶å€¼ç®¡ç†
  â”œâ”€â”€ value_manager.cpp
  â”œâ”€â”€ ir_generator.h       # ä¸»ç”Ÿæˆå™¨(è®¿é—®è€…)
  â””â”€â”€ ir_generator.cpp
```

---

### æ­¥éª¤ 2: å®ç° IREmitter ç±» (2-3 å°æ—¶)

**ç›®çš„**: ç›´æ¥è¾“å‡º LLVM IR æ–‡æœ¬,ç®¡ç†è¾“å‡ºæµ

#### 2.1 ir_emitter.h

**è®¾è®¡è¦ç‚¹**:

- ä½¿ç”¨`std::stringstream`ç´¯ç§¯ IR æ–‡æœ¬
- æä¾›å„ç§ IR æŒ‡ä»¤çš„æ–‡æœ¬ç”Ÿæˆæ–¹æ³•
- ç®¡ç†ç¼©è¿›å’Œæ ¼å¼åŒ–
- ç®¡ç†ä¸´æ—¶å˜é‡è®¡æ•°å™¨

**æ ¸å¿ƒæ¥å£**:

```cpp
#pragma once
#include <string>
#include <sstream>
#include <vector>

class IREmitter {
public:
    IREmitter(const std::string& module_name);

    // ========== Moduleçº§åˆ« ==========
    // è¾“å‡ºModuleå¤´éƒ¨æ³¨é‡Š
    void emit_module_header();

    // è¾“å‡ºå…¨å±€å˜é‡å£°æ˜
    void emit_global_variable(const std::string& name,
                             const std::string& type,
                             const std::string& initializer);

    // è¾“å‡ºç»“æ„ä½“ç±»å‹å®šä¹‰
    void emit_struct_type(const std::string& name,
                         const std::vector<std::string>& field_types);

    // ========== å‡½æ•°çº§åˆ« ==========
    // å¼€å§‹å‡½æ•°å®šä¹‰
    void begin_function(const std::string& return_type,
                       const std::string& name,
                       const std::vector<std::pair<std::string, std::string>>& params);

    // ç»“æŸå‡½æ•°å®šä¹‰
    void end_function();

    // ========== åŸºæœ¬å— ==========
    // åˆ›å»ºå¹¶è¿›å…¥æ–°çš„åŸºæœ¬å—
    void begin_basic_block(const std::string& label);

    // ========== æŒ‡ä»¤ç”Ÿæˆ ==========
    // allocaæŒ‡ä»¤: %ptr = alloca type
    std::string emit_alloca(const std::string& type,
                           const std::string& var_name = "");

    // storeæŒ‡ä»¤: store type value, type* ptr
    void emit_store(const std::string& value_type,
                   const std::string& value,
                   const std::string& ptr);

    // loadæŒ‡ä»¤: %result = load type, type* ptr
    std::string emit_load(const std::string& type,
                         const std::string& ptr);

    // äºŒå…ƒè¿ç®—: %result = add type op1, op2
    std::string emit_binary_op(const std::string& op,
                              const std::string& type,
                              const std::string& lhs,
                              const std::string& rhs);

    // æ¯”è¾ƒæŒ‡ä»¤: %result = icmp pred type op1, op2
    std::string emit_icmp(const std::string& predicate,
                         const std::string& type,
                         const std::string& lhs,
                         const std::string& rhs);

    // è¿”å›æŒ‡ä»¤: ret type value
    void emit_ret(const std::string& type, const std::string& value);

    // è¿”å›void: ret void
    void emit_ret_void();

    // æ— æ¡ä»¶è·³è½¬: br label %target
    void emit_br(const std::string& target_label);

    // æ¡ä»¶è·³è½¬: br i1 %cond, label %true_bb, label %false_bb
    void emit_cond_br(const std::string& condition,
                     const std::string& true_label,
                     const std::string& false_label);

    // PHIèŠ‚ç‚¹: %result = phi type [value1, %label1], [value2, %label2], ...
    std::string emit_phi(const std::string& type,
                        const std::vector<std::pair<std::string, std::string>>& incoming);

    // callæŒ‡ä»¤: %result = call return_type @func(args...)
    std::string emit_call(const std::string& return_type,
                         const std::string& func_name,
                         const std::vector<std::pair<std::string, std::string>>& args);

    // GEPæŒ‡ä»¤(æ•°ç»„/ç»“æ„ä½“è®¿é—®)
    std::string emit_getelementptr(const std::string& type,
                                   const std::string& ptr,
                                   const std::vector<std::string>& indices);

    // ========== ä¸´æ—¶å˜é‡ç®¡ç† ==========
    // è·å–æ–°çš„ä¸´æ—¶å˜é‡å(å¦‚%0, %1, %2...)
    std::string new_temp();

    // è·å–æ–°çš„æ ‡ç­¾å(å¦‚label0, label1...)
    std::string new_label();

    // ========== è¾“å‡º ==========
    // å°†ç´¯ç§¯çš„IRè¾“å‡ºåˆ°æ–‡ä»¶
    void write_to_file(const std::string& filename);

    // è¾“å‡ºåˆ°stdout(ç”¨äºè°ƒè¯•)
    void write_to_stdout();

    // è·å–ç”Ÿæˆçš„IRå­—ç¬¦ä¸²
    std::string get_ir_string() const;

private:
    std::string module_name_;
    std::stringstream ir_stream_;  // ç´¯ç§¯çš„IRæ–‡æœ¬

    int temp_counter_;   // ä¸´æ—¶å˜é‡è®¡æ•°
    int label_counter_;  // æ ‡ç­¾è®¡æ•°
    int indent_level_;   // ç¼©è¿›å±‚çº§

    // è¾…åŠ©æ–¹æ³•
    void emit_line(const std::string& line);  // è¾“å‡ºä¸€è¡Œ(å¸¦ç¼©è¿›)
    void emit_raw(const std::string& text);   // ç›´æ¥è¾“å‡º(ä¸å¸¦ç¼©è¿›)
    std::string indent() const;               // è·å–å½“å‰ç¼©è¿›å­—ç¬¦ä¸²
};
```

**å®ç°é‡ç‚¹**:

1. æ‰€æœ‰æŒ‡ä»¤éƒ½æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥
2. ä¸´æ—¶å˜é‡è‡ªåŠ¨ç¼–å·(%0, %1, %2...)
3. æ ‡ç­¾è‡ªåŠ¨ç¼–å·(label0, label1...)
4. ç»´æŠ¤ç¼©è¿›ä½¿è¾“å‡ºå¯è¯»

#### 2.2 ir_emitter.cpp

**å…³é”®å®ç°**:

```cpp
#include "ir_emitter.h"
#include <fstream>
#include <iostream>

IREmitter::IREmitter(const std::string& module_name)
    : module_name_(module_name),
      temp_counter_(0),
      label_counter_(0),
      indent_level_(0) {
    emit_module_header();
}

void IREmitter::emit_module_header() {
    ir_stream_ << "; ModuleID = '" << module_name_ << "'\n";
    ir_stream_ << "source_filename = \"" << module_name_ << "\"\n\n";
}

void IREmitter::emit_struct_type(const std::string& name,
                                 const std::vector<std::string>& field_types) {
    ir_stream_ << "%" << name << " = type { ";
    for (size_t i = 0; i < field_types.size(); ++i) {
        ir_stream_ << field_types[i];
        if (i + 1 < field_types.size()) {
            ir_stream_ << ", ";
        }
    }
    ir_stream_ << " }\n";
}

void IREmitter::begin_function(const std::string& return_type,
                               const std::string& name,
                               const std::vector<std::pair<std::string, std::string>>& params) {
    // define return_type @name(type1 %param1, type2 %param2, ...) {
    ir_stream_ << "\ndefine " << return_type << " @" << name << "(";

    for (size_t i = 0; i < params.size(); ++i) {
        ir_stream_ << params[i].first << " %" << params[i].second;
        if (i + 1 < params.size()) {
            ir_stream_ << ", ";
        }
    }

    ir_stream_ << ") {\n";
    indent_level_++;
}

void IREmitter::end_function() {
    indent_level_--;
    ir_stream_ << "}\n";
}

void IREmitter::begin_basic_block(const std::string& label) {
    // label:
    // åŸºæœ¬å—æ ‡ç­¾ä¸ç¼©è¿›
    ir_stream_ << label << ":\n";
}

std::string IREmitter::emit_alloca(const std::string& type,
                                   const std::string& var_name) {
    std::string result = new_temp();
    std::string name_comment = var_name.empty() ? "" : " ; " + var_name;
    emit_line(result + " = alloca " + type + name_comment);
    return result;
}

void IREmitter::emit_store(const std::string& value_type,
                           const std::string& value,
                           const std::string& ptr) {
    emit_line("store " + value_type + " " + value + ", " +
              value_type + "* " + ptr);
}

std::string IREmitter::emit_load(const std::string& type,
                                 const std::string& ptr) {
    std::string result = new_temp();
    emit_line(result + " = load " + type + ", " + type + "* " + ptr);
    return result;
}

std::string IREmitter::emit_binary_op(const std::string& op,
                                      const std::string& type,
                                      const std::string& lhs,
                                      const std::string& rhs) {
    std::string result = new_temp();
    emit_line(result + " = " + op + " " + type + " " + lhs + ", " + rhs);
    return result;
}

std::string IREmitter::emit_icmp(const std::string& predicate,
                                 const std::string& type,
                                 const std::string& lhs,
                                 const std::string& rhs) {
    std::string result = new_temp();
    emit_line(result + " = icmp " + predicate + " " + type + " " +
              lhs + ", " + rhs);
    return result;
}

void IREmitter::emit_ret(const std::string& type, const std::string& value) {
    emit_line("ret " + type + " " + value);
}

void IREmitter::emit_ret_void() {
    emit_line("ret void");
}

void IREmitter::emit_br(const std::string& target_label) {
    emit_line("br label %" + target_label);
}

void IREmitter::emit_cond_br(const std::string& condition,
                             const std::string& true_label,
                             const std::string& false_label) {
    emit_line("br i1 " + condition + ", label %" + true_label +
              ", label %" + false_label);
}

std::string IREmitter::emit_phi(const std::string& type,
                                const std::vector<std::pair<std::string, std::string>>& incoming) {
    std::string result = new_temp();
    std::string phi_str = result + " = phi " + type + " ";

    for (size_t i = 0; i < incoming.size(); ++i) {
        phi_str += "[" + incoming[i].first + ", %" + incoming[i].second + "]";
        if (i + 1 < incoming.size()) {
            phi_str += ", ";
        }
    }

    emit_line(phi_str);
    return result;
}

std::string IREmitter::emit_call(const std::string& return_type,
                                 const std::string& func_name,
                                 const std::vector<std::pair<std::string, std::string>>& args) {
    std::string result = new_temp();
    std::string call_str = result + " = call " + return_type + " @" + func_name + "(";

    for (size_t i = 0; i < args.size(); ++i) {
        call_str += args[i].first + " " + args[i].second;
        if (i + 1 < args.size()) {
            call_str += ", ";
        }
    }

    call_str += ")";
    emit_line(call_str);
    return result;
}

std::string IREmitter::emit_getelementptr(const std::string& type,
                                          const std::string& ptr,
                                          const std::vector<std::string>& indices) {
    std::string result = new_temp();
    std::string gep_str = result + " = getelementptr " + type + ", " +
                         type + "* " + ptr;

    for (const auto& idx : indices) {
        gep_str += ", " + idx;
    }

    emit_line(gep_str);
    return result;
}

std::string IREmitter::new_temp() {
    return "%" + std::to_string(temp_counter_++);
}

std::string IREmitter::new_label() {
    return "label" + std::to_string(label_counter_++);
}

void IREmitter::emit_line(const std::string& line) {
    ir_stream_ << indent() << line << "\n";
}

void IREmitter::emit_raw(const std::string& text) {
    ir_stream_ << text;
}

std::string IREmitter::indent() const {
    return std::string(indent_level_ * 2, ' ');  // 2ç©ºæ ¼ç¼©è¿›
}

void IREmitter::write_to_file(const std::string& filename) {
    std::ofstream out(filename);
    if (!out) {
        std::cerr << "Error: Cannot open file " << filename << std::endl;
        return;
    }
    out << ir_stream_.str();
    out.close();
}

void IREmitter::write_to_stdout() {
    std::cout << ir_stream_.str();
}

std::string IREmitter::get_ir_string() const {
    return ir_stream_.str();
}
```

**æµ‹è¯•ç‚¹**:

- åˆ›å»º IREmitter å¯¹è±¡ä¸å´©æºƒ
- emit_module_header è¾“å‡ºæ­£ç¡®çš„å¤´éƒ¨
- ä¸´æ—¶å˜é‡ç¼–å·æ­£ç¡®é€’å¢
- è¾“å‡ºåˆ°æ–‡ä»¶æˆåŠŸ

---

### æ­¥éª¤ 3: å®ç° TypeMapper ç±» (2-3 å°æ—¶)

**ç›®çš„**: å°† Rust ç±»å‹è½¬æ¢ä¸º LLVM IR ç±»å‹çš„å­—ç¬¦ä¸²è¡¨ç¤º

#### 3.1 type_mapper.h

**è®¾è®¡è¦ç‚¹**:

- å°† Rust ç±»å‹æ˜ å°„ä¸º IR ç±»å‹å­—ç¬¦ä¸²(å¦‚"i32", "i1", "[10 x i32]")
- ä¸éœ€è¦ LLVM åº“,çº¯å­—ç¬¦ä¸²æ“ä½œ
- ç¼“å­˜å·²è½¬æ¢çš„ç±»å‹å­—ç¬¦ä¸²

**æ ¸å¿ƒæ¥å£**:

```cpp
#pragma once
#include "../semantic/semantic.h"
#include <string>
#include <unordered_map>

class TypeMapper {
public:
    TypeMapper(BuiltinTypes& builtin_types);

    // ä¸»è½¬æ¢æ¥å£:è¿”å›IRç±»å‹å­—ç¬¦ä¸²
    std::string map(const Type* rust_type);

    // ç‰¹å®šç±»å‹è½¬æ¢
    std::string map_primitive(const PrimitiveType* type);
    std::string map_array(const ArrayType* type);
    std::string map_struct(const StructType* type);
    std::string map_function(const FunctionType* type);
    std::string map_reference(const ReferenceType* type);

    // è·å–ç±»å‹çš„é›¶å€¼å­—ç¬¦ä¸²è¡¨ç¤º
    std::string get_zero_value(const Type* type);

    // æ³¨å†Œç»“æ„ä½“ç±»å‹å®šä¹‰(è¿”å›éœ€è¦åœ¨Moduleä¸­å£°æ˜çš„å­—ç¬¦ä¸²)
    std::string declare_struct_type(const StructType* type);

private:
    BuiltinTypes& builtin_types_;

    // ç±»å‹ç¼“å­˜: Rust Type -> IRç±»å‹å­—ç¬¦ä¸²
    std::unordered_map<const Type*, std::string> type_cache_;

    // ç»“æ„ä½“åç§°ç¼“å­˜
    std::unordered_map<std::string, bool> declared_structs_;
};
```

#### 3.2 type_mapper.cpp

**å…³é”®å®ç°**:

```cpp
#include "type_mapper.h"
#include <sstream>

TypeMapper::TypeMapper(BuiltinTypes& builtin_types)
    : builtin_types_(builtin_types) {
}

std::string TypeMapper::map(const Type* rust_type) {
    if (!rust_type) {
        return "void";
    }

    // 1. æ£€æŸ¥ç¼“å­˜
    auto it = type_cache_.find(rust_type);
    if (it != type_cache_.end()) {
        return it->second;
    }

    // 2. æ ¹æ®ç±»å‹ç§ç±»åˆ†å‘
    std::string ir_type;

    switch (rust_type->kind) {
        case TypeKind::I32:
        case TypeKind::U32:
        case TypeKind::I64:
        case TypeKind::U64:
        case TypeKind::I8:
        case TypeKind::U8:
        case TypeKind::BOOL:
        case TypeKind::CHAR:
        case TypeKind::ISIZE:
        case TypeKind::USIZE:
            ir_type = map_primitive(
                static_cast<const PrimitiveType*>(rust_type)
            );
            break;

        case TypeKind::ARRAY:
            ir_type = map_array(
                static_cast<const ArrayType*>(rust_type)
            );
            break;

        case TypeKind::STRUCT:
            ir_type = map_struct(
                static_cast<const StructType*>(rust_type)
            );
            break;

        case TypeKind::FUNCTION:
            ir_type = map_function(
                static_cast<const FunctionType*>(rust_type)
            );
            break;

        case TypeKind::REFERENCE:
        case TypeKind::RAW_POINTER:
            ir_type = map_reference(
                static_cast<const ReferenceType*>(rust_type)
            );
            break;

        case TypeKind::UNIT:
            ir_type = "void";
            break;

        default:
            // æœªæ”¯æŒçš„ç±»å‹,æš‚æ—¶è¿”å›i32
            ir_type = "i32";
            break;
    }

    // 3. åŠ å…¥ç¼“å­˜
    type_cache_[rust_type] = ir_type;

    return ir_type;
}

std::string TypeMapper::map_primitive(const PrimitiveType* type) {
    switch (type->kind) {
        case TypeKind::I32:
        case TypeKind::U32:
            return "i32";

        case TypeKind::I64:
        case TypeKind::U64:
        case TypeKind::ISIZE:
        case TypeKind::USIZE:
            return "i64";

        case TypeKind::I8:
        case TypeKind::U8:
            return "i8";

        case TypeKind::I16:
        case TypeKind::U16:
            return "i16";

        case TypeKind::BOOL:
            return "i1";

        case TypeKind::CHAR:
            return "i32";  // Unicodeæ ‡é‡å€¼

        default:
            return "i32";  // é»˜è®¤
    }
}

std::string TypeMapper::map_array(const ArrayType* type) {
    // [T; N] -> [N x T_ir]
    std::string elem_type = map(type->element_type.get());
    return "[" + std::to_string(type->size) + " x " + elem_type + "]";
}

std::string TypeMapper::map_struct(const StructType* type) {
    // struct Point -> %Point
    return "%" + type->name;
}

std::string TypeMapper::map_function(const FunctionType* type) {
    // fn(T1, T2) -> R  =>  R (T1, T2)*

    std::string ret_type = map(type->return_type.get());

    std::stringstream ss;
    ss << ret_type << " (";

    for (size_t i = 0; i < type->param_types.size(); ++i) {
        ss << map(type->param_types[i].get());
        if (i + 1 < type->param_types.size()) {
            ss << ", ";
        }
    }

    ss << ")*";  // å‡½æ•°æŒ‡é’ˆç±»å‹
    return ss.str();
}

std::string TypeMapper::map_reference(const ReferenceType* type) {
    // &T å’Œ &mut T éƒ½æ˜ å°„ä¸º T*
    std::string pointee_type = map(type->referenced_type.get());
    return pointee_type + "*";
}

std::string TypeMapper::get_zero_value(const Type* type) {
    if (!type) {
        return "void";
    }

    switch (type->kind) {
        case TypeKind::I32:
        case TypeKind::U32:
        case TypeKind::I64:
        case TypeKind::U64:
        case TypeKind::I8:
        case TypeKind::U8:
        case TypeKind::ISIZE:
        case TypeKind::USIZE:
        case TypeKind::CHAR:
            return "0";

        case TypeKind::BOOL:
            return "false";

        case TypeKind::REFERENCE:
        case TypeKind::RAW_POINTER:
            return "null";

        case TypeKind::ARRAY:
            return "zeroinitializer";

        case TypeKind::STRUCT:
            return "zeroinitializer";

        default:
            return "0";
    }
}

std::string TypeMapper::declare_struct_type(const StructType* type) {
    // æ£€æŸ¥æ˜¯å¦å·²å£°æ˜
    if (declared_structs_[type->name]) {
        return "";
    }

    declared_structs_[type->name] = true;

    // ç”Ÿæˆ: %Point = type { i32, i32 }
    std::stringstream ss;
    ss << "%" << type->name << " = type { ";

    for (size_t i = 0; i < type->fields.size(); ++i) {
        ss << map(type->fields[i].type.get());
        if (i + 1 < type->fields.size()) {
            ss << ", ";
        }
    }

    ss << " }\n";
    return ss.str();
}
```

**æµ‹è¯•ç‚¹**:

- i32 æ˜ å°„ä¸º"i32"
- [i32; 10]æ˜ å°„ä¸º"[10 x i32]"
- struct Point æ˜ å°„ä¸º"%Point"
- ç¼“å­˜æœºåˆ¶ç”Ÿæ•ˆ

---

### æ­¥éª¤ 4: å®ç° ValueManager ç±» (2-3 å°æ—¶)

**ç›®çš„**: ç®¡ç†å˜é‡åˆ° LLVM Value çš„æ˜ å°„,å¤„ç†ä½œç”¨åŸŸ

#### 4.1 value_manager.h

**è®¾è®¡è¦ç‚¹**:

- ä½œç”¨åŸŸæ ˆç®¡ç†
- å˜é‡ååˆ° alloca çš„æ˜ å°„
- æ”¯æŒå˜é‡é®è”½(shadowing)

**æ ¸å¿ƒæ¥å£**:

```cpp
struct VariableInfo {
    llvm::Value* alloca_inst;  // æ ˆä¸Šåˆ†é…çš„åœ°å€
    llvm::Type* type;          // å˜é‡ç±»å‹
    bool is_mutable;           // æ˜¯å¦å¯å˜
};

class ValueManager {
public:
    ValueManager();

    // ä½œç”¨åŸŸç®¡ç†
    void enter_scope();
    void exit_scope();

    // å˜é‡å®šä¹‰(åœ¨å½“å‰ä½œç”¨åŸŸ)
    void define_variable(const std::string& name,
                        llvm::Value* alloca,
                        llvm::Type* type,
                        bool is_mutable);

    // å˜é‡æŸ¥æ‰¾(ä»å½“å‰å‘å¤–å±‚æŸ¥æ‰¾)
    VariableInfo* lookup_variable(const std::string& name);

    // æ£€æŸ¥å½“å‰ä½œç”¨åŸŸæ˜¯å¦å·²å®šä¹‰(ç”¨äºæ£€æµ‹é‡å¤å®šä¹‰)
    bool is_defined_in_current_scope(const std::string& name);

private:
    struct Scope {
        std::unordered_map<std::string, VariableInfo> variables;
    };

    std::vector<Scope> scope_stack_;
};
```

#### 4.2 value_manager.cpp

**å®ç°è¦ç‚¹**:

```cpp
#include "value_manager.h"

ValueManager::ValueManager() {
    // åˆ›å»ºå…¨å±€ä½œç”¨åŸŸ
    enter_scope();
}

void ValueManager::enter_scope() {
    scope_stack_.emplace_back();
}

void ValueManager::exit_scope() {
    if (scope_stack_.size() > 1) {  // ä¿ç•™å…¨å±€ä½œç”¨åŸŸ
        scope_stack_.pop_back();
    }
}

void ValueManager::define_variable(const std::string& name,
                                   llvm::Value* alloca,
                                   llvm::Type* type,
                                   bool is_mutable) {
    if (scope_stack_.empty()) {
        return;  // é”™è¯¯æƒ…å†µ
    }

    VariableInfo info;
    info.alloca_inst = alloca;
    info.type = type;
    info.is_mutable = is_mutable;

    scope_stack_.back().variables[name] = info;
}

VariableInfo* ValueManager::lookup_variable(const std::string& name) {
    // ä»æœ€å†…å±‚å‘å¤–æŸ¥æ‰¾
    for (auto it = scope_stack_.rbegin(); it != scope_stack_.rend(); ++it) {
        auto var_it = it->variables.find(name);
        if (var_it != it->variables.end()) {
            return &var_it->second;
        }
    }
    return nullptr;  // æœªæ‰¾åˆ°
}

bool ValueManager::is_defined_in_current_scope(const std::string& name) {
    if (scope_stack_.empty()) {
        return false;
    }

    return scope_stack_.back().variables.find(name) !=
           scope_stack_.back().variables.end();
}
```

**æµ‹è¯•ç‚¹**:

- enter/exit é…å¯¹
- å˜é‡å®šä¹‰å’ŒæŸ¥æ‰¾
- å¤–å±‚å˜é‡åœ¨å†…å±‚å¯è§
- å˜é‡é®è”½æ­£ç¡®å¤„ç†

---

### æ­¥éª¤ 5: å®ç° IRGenerator éª¨æ¶ (3-4 å°æ—¶)

**ç›®çš„**: æ­å»ºä¸»ç”Ÿæˆå™¨æ¡†æ¶,å®ç° visitor æ¥å£

#### 5.1 ir_generator.h

**è®¾è®¡è¦ç‚¹**:

- ç»§æ‰¿æ‰€æœ‰ visitor æ¥å£
- ç»„åˆä½¿ç”¨ IREmitterã€TypeMapperã€ValueManager
- ç»´æŠ¤å½“å‰çŠ¶æ€(å‡½æ•°ã€åŸºæœ¬å—ç­‰)

**æ ¸å¿ƒæ¥å£**:

```cpp
#pragma once
#include "../ast/ast.h"
#include "../semantic/semantic.h"
#include "../error/error.h"
#include "ir_emitter.h"
#include "type_mapper.h"
#include "value_manager.h"

class IRGenerator : public ExprVisitor<std::string>,  // è¿”å›IRå€¼å­—ç¬¦ä¸²
                   public StmtVisitor,
                   public ItemVisitor {
public:
    IRGenerator(const std::string& module_name,
               SymbolTable& symbol_table,
               BuiltinTypes& builtin_types,
               ErrorReporter& error_reporter);

    // ä¸»å…¥å£:ç”Ÿæˆæ•´ä¸ªç¨‹åºçš„IR
    void generate(Program* program);

    // è·å–ç”Ÿæˆçš„IRæ–‡æœ¬(ç”¨äºè¾“å‡º)
    std::string get_ir_string() const;

    // è¾“å‡ºåˆ°æ–‡ä»¶
    void write_to_file(const std::string& filename);

    // ============ Expression Visitors ============
    // è¿”å›è¡¨ç¤ºè¯¥è¡¨è¾¾å¼å€¼çš„IRå­—ç¬¦ä¸²(å¦‚"%0", "42", "true")
    std::string visit(LiteralExpr* node) override;
    std::string visit(VariableExpr* node) override;
    std::string visit(BinaryExpr* node) override;
    std::string visit(UnaryExpr* node) override;
    std::string visit(CallExpr* node) override;
    std::string visit(IfExpr* node) override;
    std::string visit(LoopExpr* node) override;
    std::string visit(WhileExpr* node) override;
    std::string visit(BlockExpr* node) override;
    std::string visit(AssignmentExpr* node) override;
    std::string visit(IndexExpr* node) override;
    std::string visit(FieldAccessExpr* node) override;
    std::string visit(ReferenceExpr* node) override;
    std::string visit(ArrayLiteralExpr* node) override;
    std::string visit(StructInitializerExpr* node) override;
    std::string visit(GroupingExpr* node) override;
    std::string visit(AsExpr* node) override;
    std::string visit(MatchExpr* node) override;
    std::string visit(PathExpr* node) override;
    std::string visit(UnitExpr* node) override;
    std::string visit(TupleExpr* node) override;
    std::string visit(ArrayInitializerExpr* node) override;
    std::string visit(CompoundAssignmentExpr* node) override;
    std::string visit(UnderscoreExpr* node) override;

    // ============ Statement Visitors ============
    void visit(BlockStmt* node) override;
    void visit(LetStmt* node) override;
    void visit(ExprStmt* node) override;
    void visit(ReturnStmt* node) override;
    void visit(BreakStmt* node) override;
    void visit(ContinueStmt* node) override;
    void visit(ItemStmt* node) override;

    // ============ Item Visitors ============
    void visit(FnDecl* node) override;
    void visit(StructDecl* node) override;
    void visit(ConstDecl* node) override;
    void visit(EnumDecl* node) override;
    void visit(ModDecl* node) override;
    void visit(TraitDecl* node) override;
    void visit(ImplBlock* node) override;

private:
    // æ ¸å¿ƒç»„ä»¶
    IREmitter emitter_;
    TypeMapper type_mapper_;
    ValueManager value_manager_;

    // ç¼–è¯‘å™¨ä¸Šä¸‹æ–‡
    SymbolTable& symbol_table_;
    BuiltinTypes& builtin_types_;
    ErrorReporter& error_reporter_;

    // å½“å‰çŠ¶æ€
    std::string current_function_name_;
    bool in_function_ = false;

    // å¾ªç¯æ§åˆ¶(ç”¨äºbreak/continue)
    std::vector<std::string> break_labels_;
    std::vector<std::string> continue_labels_;

    // è¾…åŠ©æ–¹æ³•
    // åœ¨å½“å‰å‡½æ•°entryå—åˆ›å»ºalloca
    std::string create_alloca_in_entry(const std::string& type,
                                      const std::string& var_name);
};
```

#### 5.2 ir_generator.cpp (åˆå§‹ç‰ˆæœ¬)

**å®ç°ç­–ç•¥**:

- æ„é€ å‡½æ•°åˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶
- generate æ–¹æ³•éå†é¡¶å±‚ item,æ”¶é›† struct å®šä¹‰,ç„¶åç”Ÿæˆå‡½æ•°
- visitor æ–¹æ³•æš‚æ—¶è¿”å›ç©ºå­—ç¬¦ä¸²/ä¸åšä»»ä½•äº‹(å ä½)

```cpp
#include "ir_generator.h"

IRGenerator::IRGenerator(const std::string& module_name,
                        SymbolTable& symbol_table,
                        BuiltinTypes& builtin_types,
                        ErrorReporter& error_reporter)
    : emitter_(module_name),
      type_mapper_(builtin_types),
      value_manager_(),
      symbol_table_(symbol_table),
      builtin_types_(builtin_types),
      error_reporter_(error_reporter) {
}

void IRGenerator::generate(Program* program) {
    if (!program) {
        return;
    }

    // ç¬¬ä¸€é:æ”¶é›†å¹¶å£°æ˜æ‰€æœ‰ç»“æ„ä½“ç±»å‹
    for (auto& item : program->items) {
        if (auto* struct_decl = dynamic_cast<StructDecl*>(item.get())) {
            struct_decl->accept(this);
        }
    }

    // ç¬¬äºŒé:ç”Ÿæˆæ‰€æœ‰å‡½æ•°
    for (auto& item : program->items) {
        if (dynamic_cast<FnDecl*>(item.get())) {
            item->accept(this);
        }
    }

    // ç¬¬ä¸‰é:å¤„ç†å…¶ä»–é¡¶å±‚item(const, enumç­‰)
    for (auto& item : program->items) {
        if (!dynamic_cast<FnDecl*>(item.get()) &&
            !dynamic_cast<StructDecl*>(item.get())) {
            item->accept(this);
        }
    }
}

std::string IRGenerator::get_ir_string() const {
    return emitter_.get_ir_string();
}

void IRGenerator::write_to_file(const std::string& filename) {
    emitter_.write_to_file(filename);
}

// ============ Expression Visitors (ç©ºå®ç°,ç¬¬äºŒé˜¶æ®µå¡«å……) ============
std::string IRGenerator::visit(LiteralExpr* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(VariableExpr* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(BinaryExpr* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(UnaryExpr* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(CallExpr* node) {
    // TODO: ç¬¬å››é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(IfExpr* node) {
    // TODO: ç¬¬ä¸‰é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(LoopExpr* node) {
    // TODO: ç¬¬ä¸‰é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(WhileExpr* node) {
    // TODO: ç¬¬ä¸‰é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(BlockExpr* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(AssignmentExpr* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(IndexExpr* node) {
    // TODO: ç¬¬äº”é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(FieldAccessExpr* node) {
    // TODO: ç¬¬äº”é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(ReferenceExpr* node) {
    // TODO: ç¬¬å…­é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(ArrayLiteralExpr* node) {
    // TODO: ç¬¬äº”é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(StructInitializerExpr* node) {
    // TODO: ç¬¬äº”é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(GroupingExpr* node) {
    return node->expr->accept(this);
}

std::string IRGenerator::visit(AsExpr* node) {
    // TODO: ç¬¬å…­é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(MatchExpr* node) {
    // TODO: åç»­å®ç°
    return "";
}

std::string IRGenerator::visit(PathExpr* node) {
    // TODO: åç»­å®ç°
    return "";
}

std::string IRGenerator::visit(UnitExpr* node) {
    return "";  // unitå€¼åœ¨IRä¸­ä¸éœ€è¦è¡¨ç¤º
}

std::string IRGenerator::visit(TupleExpr* node) {
    // TODO: åç»­å®ç°
    return "";
}

std::string IRGenerator::visit(ArrayInitializerExpr* node) {
    // TODO: ç¬¬äº”é˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(CompoundAssignmentExpr* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    return "";
}

std::string IRGenerator::visit(UnderscoreExpr* node) {
    return "";  // ä¸‹åˆ’çº¿è¡¨è¾¾å¼ä¸ç”Ÿæˆå€¼
}

// ============ Statement Visitors (ç©ºå®ç°) ============
void IRGenerator::visit(BlockStmt* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
}

void IRGenerator::visit(LetStmt* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
}

void IRGenerator::visit(ExprStmt* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
}

void IRGenerator::visit(ReturnStmt* node) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
}

void IRGenerator::visit(BreakStmt* node) {
    // TODO: ç¬¬ä¸‰é˜¶æ®µå®ç°
}

void IRGenerator::visit(ContinueStmt* node) {
    // TODO: ç¬¬ä¸‰é˜¶æ®µå®ç°
}

void IRGenerator::visit(ItemStmt* node) {
    if (node->item) {
        node->item->accept(this);
    }
}

// ============ Item Visitors ============
void IRGenerator::visit(FnDecl* node) {
    // TODO: ç¬¬å››é˜¶æ®µå®ç°
    // æš‚æ—¶ç”Ÿæˆç©ºå‡½æ•°æ¡†æ¶ç”¨äºæµ‹è¯•
}

void IRGenerator::visit(StructDecl* node) {
    // ç”Ÿæˆç»“æ„ä½“ç±»å‹å£°æ˜
    if (!node->type) return;

    auto* struct_type = dynamic_cast<StructType*>(node->type.get());
    if (struct_type) {
        std::string decl = type_mapper_.declare_struct_type(struct_type);
        // æ³¨æ„:IREmitteréœ€è¦æ·»åŠ emit_raw_lineæ–¹æ³•æ¥è¾“å‡ºç±»å‹å£°æ˜
        // æˆ–è€…åœ¨generate()ä¸­å•ç‹¬å¤„ç†
    }
}

void IRGenerator::visit(ConstDecl* node) {
    // TODO: åç»­å®ç°å…¨å±€å¸¸é‡
}

void IRGenerator::visit(EnumDecl* node) {
    // TODO: åç»­å®ç°æšä¸¾
}

void IRGenerator::visit(ModDecl* node) {
    // TODO: åç»­å®ç°æ¨¡å—
}

void IRGenerator::visit(TraitDecl* node) {
    // TODO: åç»­å®ç°trait
}

void IRGenerator::visit(ImplBlock* node) {
    // TODO: åç»­å®ç°implå—
}

// ============ è¾…åŠ©æ–¹æ³• ============
std::string IRGenerator::create_alloca_in_entry(const std::string& type,
                                                const std::string& var_name) {
    // TODO: ç¬¬äºŒé˜¶æ®µå®ç°
    // éœ€è¦åœ¨å‡½æ•°entryå—å¼€å§‹å¤„åˆ›å»ºalloca
    return "";
}
```

**éªŒè¯ç‚¹**:

- ç¼–è¯‘é€šè¿‡
- èƒ½å®ä¾‹åŒ– IRGenerator
- è°ƒç”¨ generate ä¸å´©æºƒ
- èƒ½è¾“å‡º Module å¤´éƒ¨

---

### æ­¥éª¤ 6: é…ç½® CMakeLists.txt (30 åˆ†é’Ÿ)

**ç›®çš„**: æ·»åŠ  IR æ¨¡å—æºæ–‡ä»¶åˆ°ç¼–è¯‘ç³»ç»Ÿ

#### 6.1 ä¿®æ”¹ CMakeLists.txt

**å…³é”®å˜åŒ–**: ä¸éœ€è¦é“¾æ¥ LLVM åº“!åªéœ€è¦æ·»åŠ æºæ–‡ä»¶

```cmake
# ===== æ·»åŠ IRæ¨¡å—æºæ–‡ä»¶ =====
set(IR_SOURCES
    src/ir/ir_emitter.cpp
    src/ir/type_mapper.cpp
    src/ir/value_manager.cpp
    src/ir/ir_generator.cpp
)

# ===== æ›´æ–°å¯æ‰§è¡Œæ–‡ä»¶ =====
add_executable(code
    src/main.cpp
    src/ast/ast.cpp
    src/lexer/lexer.cpp
    src/parser/parser.cpp
    src/pre_processor/pre_processor.cpp
    src/semantic/semantic.cpp
    src/semantic/name_resolution.cpp
    src/semantic/type_check.cpp
    src/semantic/type_resolve.cpp
    src/semantic/const_evaluate.cpp
    src/tool/number.cpp
    src/error/error.cpp
    ${IR_SOURCES}  # æ·»åŠ IRæ¨¡å—
)

# ===== è®¾ç½®C++æ ‡å‡† =====
set_property(TARGET code PROPERTY CXX_STANDARD 17)
```

**æ³¨æ„**:

- **ä¸éœ€è¦**`find_package(LLVM)`
- **ä¸éœ€è¦**é“¾æ¥ LLVM åº“
- åªéœ€è¦æ ‡å‡† C++åº“å³å¯

#### 6.2 æµ‹è¯•ç¼–è¯‘

```bash
cd /home/louhao/compiler/build
cmake ..
make
```

**é¢„æœŸç»“æœ**:

- ç¼–è¯‘é€šè¿‡(ä¸éœ€è¦ LLVM)
- ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶
- æ²¡æœ‰é“¾æ¥é”™è¯¯

---

### æ­¥éª¤ 7: é›†æˆåˆ°ä¸»æµç¨‹ (1 å°æ—¶)

**ç›®çš„**: åœ¨ main.cpp ä¸­è°ƒç”¨ IR ç”Ÿæˆ

#### 7.1 ä¿®æ”¹ main.cpp

åœ¨è¯­ä¹‰åˆ†æåæ·»åŠ  IR ç”Ÿæˆ:

```cpp
#include "ir/ir_generator.h"

int main(int argc, char* argv[]) {
    // ... ç°æœ‰çš„é¢„å¤„ç†ã€è¯æ³•ã€è¯­æ³•ã€è¯­ä¹‰åˆ†æä»£ç  ...

    // ===== IRç”Ÿæˆé˜¶æ®µ =====
    std::cout << "=== IR Generation ===" << std::endl;

    IRGenerator ir_gen(
        "my_module",
        /* ä¼ å…¥symbol_table */,
        builtin_types,
        error_reporter
    );

    ir_gen.generate(ast.get());

    if (error_reporter.has_errors()) {
        std::cerr << "IR generation failed with errors" << std::endl;
        return 1;
    }

    // è¾“å‡ºç”Ÿæˆçš„IR
    std::string output_file = "output.ll";
    ir_gen.write_to_file(output_file);
    std::cout << "IR written to " << output_file << std::endl;

    // æ³¨æ„:ç”±äºæ˜¯æ‰‹åŠ¨ç”Ÿæˆæ–‡æœ¬,æˆ‘ä»¬ä¸èƒ½ç”¨LLVMéªŒè¯
    // éœ€è¦ç”¨å¤–éƒ¨å·¥å…·llvm-asæ¥éªŒè¯
    std::cout << "Run 'llvm-as output.ll' to verify the IR" << std::endl;

    return 0;
}
```

---

### æ­¥éª¤ 8: åˆ›å»ºæµ‹è¯•ç”¨ä¾‹ (1 å°æ—¶)

**ç›®çš„**: éªŒè¯åŸºç¡€æ¡†æ¶æ­£å¸¸å·¥ä½œ

#### 8.1 åˆ›å»ºæœ€ç®€æµ‹è¯• test_ir_basic.rs

```rust
// testcases/ir/test_basic.rs
// æœ€ç®€å•çš„ç¨‹åº:ç©ºmainå‡½æ•°
fn main() {
}
```

#### 8.2 è¿è¡Œæµ‹è¯•

```bash
cd /home/louhao/compiler/build
./code ../testcases/ir/test_basic.rs
```

**é¢„æœŸè¾“å‡º**:

```
=== Preprocessing ===
=== Lexing ===
=== Parsing ===
=== Semantic Analysis ===
=== IR Generation ===
IR written to output.ll
Run 'llvm-as output.ll' to verify the IR
```

#### 8.3 æ£€æŸ¥ç”Ÿæˆçš„ IR

```bash
cat output.ll
```

**é¢„æœŸå†…å®¹**(åº”è¯¥æ˜¯ä¸€ä¸ªç©º Module):

```llvm
; ModuleID = 'my_module'
source_filename = "my_module"
```

#### 8.4 éªŒè¯ IR åˆæ³•æ€§

```bash
llvm-as output.ll
```

åº”è¯¥æ²¡æœ‰é”™è¯¯è¾“å‡ºã€‚

---

## ç¬¬ä¸€é˜¶æ®µéªŒæ”¶æ ‡å‡†

å®Œæˆä»¥ä¸‹æ‰€æœ‰é¡¹ç›®å³å®Œæˆç¬¬ä¸€é˜¶æ®µ:

- [ ] åˆ›å»ºäº†æ‰€æœ‰åŸºç¡€æ–‡ä»¶(8 ä¸ªæ–‡ä»¶)
- [ ] IREmitter ç±»èƒ½è¾“å‡º IR æ–‡æœ¬
- [ ] IREmitter èƒ½ç®¡ç†ä¸´æ—¶å˜é‡å’Œæ ‡ç­¾ç¼–å·
- [ ] TypeMapper èƒ½è½¬æ¢åŸºæœ¬ç±»å‹ä¸º IR å­—ç¬¦ä¸²(i32, i1 ç­‰)
- [ ] TypeMapper èƒ½è½¬æ¢æ•°ç»„ç±»å‹ä¸º IR å­—ç¬¦ä¸²([10 x i32])
- [ ] TypeMapper èƒ½ç”Ÿæˆç»“æ„ä½“ç±»å‹å£°æ˜
- [ ] ValueManager èƒ½ç®¡ç†ä½œç”¨åŸŸå’Œå˜é‡æ˜ å°„
- [ ] IRGenerator éª¨æ¶å®Œæ•´(æ‰€æœ‰ visitor æ–¹æ³•å­˜åœ¨)
- [ ] CMakeLists.txt é…ç½®æ­£ç¡®,ç¼–è¯‘é€šè¿‡(ä¸éœ€è¦ LLVM åº“)
- [ ] main.cpp é›†æˆäº† IR ç”Ÿæˆæµç¨‹
- [ ] èƒ½ç”Ÿæˆç©ºçš„ä½†æ ¼å¼æ­£ç¡®çš„.ll æ–‡ä»¶
- [ ] è¾“å‡ºçš„.ll æ–‡ä»¶èƒ½é€šè¿‡ llvm-as éªŒè¯

---

## è°ƒè¯•æŠ€å·§

### ç¼–è¯‘é”™è¯¯

**æ‰¾ä¸åˆ°å¤´æ–‡ä»¶**:

- æ£€æŸ¥ include è·¯å¾„æ˜¯å¦æ­£ç¡®
- ç¡®ä¿æ‰€æœ‰.h æ–‡ä»¶éƒ½åˆ›å»ºäº†

**æœªå®šä¹‰çš„å¼•ç”¨**:

- æ£€æŸ¥æ˜¯å¦æ‰€æœ‰.cpp æ–‡ä»¶éƒ½æ·»åŠ åˆ° CMakeLists.txt
- ç¡®ä¿æ–¹æ³•å£°æ˜å’Œå®ç°åŒ¹é…

### è¿è¡Œæ—¶é”™è¯¯

**Segmentation Fault**:

- æ£€æŸ¥æŒ‡é’ˆæ˜¯å¦åˆå§‹åŒ–
- ä½¿ç”¨ gdb è°ƒè¯•:

```bash
gdb ./code
run ../testcases/ir/test_basic.rs
bt  # æŸ¥çœ‹è°ƒç”¨æ ˆ
```

**ç”Ÿæˆçš„ IR æ ¼å¼é”™è¯¯**:

- æŸ¥çœ‹ output.ll æ–‡ä»¶å†…å®¹
- ä½¿ç”¨ llvm-as éªŒè¯:

```bash
llvm-as output.ll -o /dev/null
```

- æ£€æŸ¥ä¸´æ—¶å˜é‡ç¼–å·æ˜¯å¦è¿ç»­
- æ£€æŸ¥ç¼©è¿›å’Œæ ¼å¼æ˜¯å¦æ­£ç¡®

---

## å¸¸è§é—®é¢˜ FAQ

### Q1: ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ LLVM åº“?

**A**: æ‰‹åŠ¨ç”Ÿæˆæ–‡æœ¬ IR èƒ½æ›´æ·±å…¥ç†è§£ LLVM IR çš„ç»“æ„å’Œè¯­æ³•,ä¸ä¾èµ–å¤–éƒ¨åº“,ç¼–è¯‘æ›´ç®€å•,è°ƒè¯•æ›´ç›´è§‚ã€‚

### Q2: ä¸ºä»€ä¹ˆè¦å…ˆå®ç° TypeMapper?

**A**: å› ä¸ºåç»­ç”ŸæˆæŒ‡ä»¤æ—¶éœ€è¦çŸ¥é“æ¯ä¸ªå€¼çš„ IR ç±»å‹å­—ç¬¦ä¸²,TypeMapper æ˜¯åŸºç¡€ã€‚

### Q3: ValueManager ç°åœ¨çœ‹èµ·æ¥ç”¨ä¸ä¸Š?

**A**: ç¬¬ä¸€é˜¶æ®µç¡®å®ç”¨ä¸ä¸Š,ä½†ç¬¬äºŒé˜¶æ®µå®ç°å˜é‡æ—¶ä¼šå¤§é‡ä½¿ç”¨ã€‚

### Q4: ç©º visitor æ–¹æ³•å¯ä»¥ä¸å®ç°å—?

**A**: å¿…é¡»å®ç°(å³ä½¿æ˜¯ç©ºçš„),å¦åˆ™æ— æ³•é€šè¿‡ç¼–è¯‘(çº¯è™šå‡½æ•°)ã€‚

### Q5: å¦‚ä½•ç¡®è®¤ç¬¬ä¸€é˜¶æ®µçœŸæ­£å®Œæˆ?

**A**: èƒ½ç”Ÿæˆä¸€ä¸ªæ ¼å¼æ­£ç¡®çš„.ll æ–‡ä»¶(å³ä½¿å†…å®¹æ˜¯ç©ºçš„),è¾“å‡ºåˆ°æ–‡ä»¶,å¹¶é€šè¿‡`llvm-as output.ll`éªŒè¯æ²¡æœ‰è¯­æ³•é”™è¯¯ã€‚

### Q6: æ‰‹åŠ¨ç”Ÿæˆ IR æ–‡æœ¬ä¼šå¾ˆå¤æ‚å—?

**A**: ä¸ä¼šã€‚LLVM IR çš„æ–‡æœ¬æ ¼å¼éå¸¸è§„æ•´,å°±æ˜¯å­—ç¬¦ä¸²æ‹¼æ¥ã€‚å…³é”®æ˜¯ç†è§£æ¯æ¡æŒ‡ä»¤çš„æ ¼å¼,IREmitter å·²ç»å°è£…å¥½äº†æ‰€æœ‰å¸¸ç”¨æŒ‡ä»¤ã€‚

### Q7: å¦‚ä½•éªŒè¯ç”Ÿæˆçš„ IR æ­£ç¡®æ€§?

**A**: ä½¿ç”¨ LLVM å·¥å…·é“¾:

- `llvm-as output.ll`:éªŒè¯è¯­æ³•
- `lli output.ll`:ç›´æ¥æ‰§è¡Œ IR
- `llc output.ll`:ç¼–è¯‘ä¸ºæ±‡ç¼–
- å¯¹æ¯”æ‰‹å†™çš„ IR ä¸ç”Ÿæˆçš„ IR

---

## ä¸‹ä¸€æ­¥é¢„å‘Š

ç¬¬ä¸€é˜¶æ®µå®Œæˆå,ä½ å°†æ‹¥æœ‰:

- âœ… å®Œæ•´çš„ IR æ–‡æœ¬ç”Ÿæˆæ¡†æ¶
- âœ… ç±»å‹åˆ° IR å­—ç¬¦ä¸²çš„æ˜ å°„æœºåˆ¶
- âœ… ä¸´æ—¶å˜é‡å’Œæ ‡ç­¾çš„è‡ªåŠ¨ç®¡ç†
- âœ… å˜é‡ä½œç”¨åŸŸç®¡ç†æœºåˆ¶
- âœ… é›†æˆçš„ç¼–è¯‘æµç¨‹
- âœ… ä¸ä¾èµ– LLVM åº“çš„çº¯ C++å®ç°

**ç¬¬äºŒé˜¶æ®µç›®æ ‡**:

- å®ç°å­—é¢é‡è¡¨è¾¾å¼(æ•´æ•°ã€å¸ƒå°”)
- å®ç°å˜é‡å®šä¹‰å’Œè®¿é—®(let + load)
- å®ç°ç®€å•äºŒå…ƒè¿ç®—(+, -, \*, /)
- ç”Ÿæˆç¬¬ä¸€ä¸ªå¯è¿è¡Œçš„ç¨‹åº!

åŠ æ²¹!å®Œæˆç¬¬ä¸€é˜¶æ®µåä½ å°±æŒæ¡äº† IR ç”Ÿæˆçš„æ ¸å¿ƒæ¡†æ¶! ğŸš€
