# Phase 2F å®ç°æŠ¥å‘Šï¼šå‡½æ•°å‚æ•°ä¼˜åŒ– + æ•°ç»„åˆå§‹åŒ–è¯­æ³•

**å®ç°æ—¥æœŸ**: 2025 å¹´ 11 æœˆ 13 æ—¥  
**å®ç°é˜¶æ®µ**: Phase 2F  
**éªŒè¯çŠ¶æ€**: âœ… 100% é€šè¿‡ llvm-as éªŒè¯

---

## ğŸ¯ å®ç°åŠŸèƒ½æ€»è§ˆ

### âœ… ä¼˜å…ˆçº§ 2ï¼šå‡½æ•°å‚æ•°ä¸è¿”å›å€¼ä¼˜åŒ–

#### 1. èšåˆç±»å‹å‚æ•°æŒ‡é’ˆä¼ é€’

**åŠŸèƒ½**: æ•°ç»„å’Œç»“æ„ä½“ä½œä¸ºå‡½æ•°å‚æ•°æ—¶ä½¿ç”¨æŒ‡é’ˆä¼ é€’ï¼Œé¿å…å¤§å¯¹è±¡å€¼æ‹·è´

**ç¤ºä¾‹**:

```rust
fn sum_array(arr: [i32; 3]) -> i32 {
    arr[0] + arr[1] + arr[2]
}
```

**ç”Ÿæˆ IR**:

```llvm
define i32 @sum_array([3 x i32]* %arr) {
  ; å‚æ•°æ˜¯æŒ‡é’ˆç±»å‹ï¼Œé«˜æ•ˆä¼ é€’
}
```

**è°ƒç”¨æ–¹**:

```llvm
%4 = call i32 @sum_array([3 x i32]* %0)  ; ä¼ é€’æŒ‡é’ˆ
```

#### 2. èšåˆç±»å‹è¿”å›å€¼å¤„ç†

**åŠŸèƒ½**: å‡½æ•°è¿”å›èšåˆç±»å‹æ—¶ï¼Œload å®Œæ•´å€¼åè¿”å›

**ç¤ºä¾‹**:

```rust
fn create_point(x: i32, y: i32) -> Point {
    Point { x: x, y: y }
}
```

**ç”Ÿæˆ IR**:

```llvm
define %Point @create_point(i32 %x, i32 %y) {
entry:
  %2 = alloca %Point
  ; ... åˆå§‹åŒ–å­—æ®µ ...
  %17 = load %Point, %Point* %2  ; loadæ•´ä¸ªç»“æ„ä½“
  ret %Point %17                  ; è¿”å›å€¼
}
```

**è°ƒç”¨æ–¹æ¥æ”¶**:

```llvm
%7 = call %Point @add_points(%Point* %0, %Point* %3)  ; æ¥æ”¶è¿”å›å€¼
%8 = alloca %Point                                     ; åˆ†é…ç©ºé—´
store %Point %7, %Point* %8                            ; å­˜å‚¨è¿”å›å€¼
```

### âœ… ä¼˜å…ˆçº§ 5ï¼šæ•°ç»„åˆå§‹åŒ–è¯­æ³• [value; size]

#### 1. å°æ•°ç»„å±•å¼€ç­–ç•¥

**åŠŸèƒ½**: å°äºç­‰äº 16 ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œå±•å¼€ä¸ºå¤šä¸ª store æŒ‡ä»¤

**ç¤ºä¾‹**:

```rust
let arr: [i32; 5] = [0; 5];
```

**ç”Ÿæˆ IR**:

```llvm
%0 = alloca [5 x i32]
%1 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i64 0, i64 0
store i32 0, i32* %1
%2 = getelementptr inbounds [5 x i32], [5 x i32]* %0, i64 0, i64 1
store i32 0, i32* %2
; ... ä¾æ¬¡åˆå§‹åŒ–5ä¸ªå…ƒç´ 
```

#### 2. å¤§æ•°ç»„å¾ªç¯ä¼˜åŒ–

**åŠŸèƒ½**: è¶…è¿‡ 16 ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œä½¿ç”¨å¾ªç¯åˆå§‹åŒ–

**ç¤ºä¾‹**:

```rust
let arr: [i32; 100] = [7; 100];
```

**ç”Ÿæˆ IR**:

```llvm
%0 = alloca [100 x i32]
%1 = alloca i64
store i64 0, i64* %1
br label %label0

label0:                          ; å¾ªç¯æ¡ä»¶
  %2 = load i64, i64* %1
  %3 = icmp slt i64 %2, 100
  br i1 %3, label %label1, label %label2

label1:                          ; å¾ªç¯ä½“
  %4 = getelementptr inbounds [100 x i32], [100 x i32]* %0, i64 0, i64 %2
  store i32 7, i32* %4
  %5 = add i64 %2, 1
  store i64 %5, i64* %1
  br label %label0

label2:                          ; å¾ªç¯ç»“æŸ
  ; ç»§ç»­æ‰§è¡Œ...
```

---

## ğŸ—ï¸ æ ¸å¿ƒå®ç°ç»†èŠ‚

### 1. å‡½æ•°å‚æ•°ä¼˜åŒ–å®ç°

**æ–‡ä»¶**: `src/ir/ir_generator.cpp` - `visit_function_decl()`

```cpp
// æ„å»ºå‚æ•°åˆ—è¡¨æ—¶æ£€æµ‹èšåˆç±»å‹
for (const auto &param : node->params) {
    auto resolved_type = param->type->resolved_type.get();
    std::string param_type_str = type_mapper_.map(resolved_type);

    // æ£€æŸ¥æ˜¯å¦ä¸ºèšåˆç±»å‹ï¼ˆæ•°ç»„æˆ–ç»“æ„ä½“ï¼‰
    bool is_aggregate = (resolved_type->kind == TypeKind::ARRAY ||
                         resolved_type->kind == TypeKind::STRUCT);

    if (is_aggregate) {
        params.push_back({param_type_str + "*", param_name});  // æŒ‡é’ˆä¼ é€’
    } else {
        params.push_back({param_type_str, param_name});        // å€¼ä¼ é€’
    }
}
```

**å‚æ•°å¤„ç†é€»è¾‘**:

- èšåˆç±»å‹å‚æ•°ï¼šç›´æ¥æ³¨å†Œå‚æ•°æŒ‡é’ˆï¼Œæ— éœ€ alloca+store
- åŸºç¡€ç±»å‹å‚æ•°ï¼šalloca + store + æ³¨å†ŒæŒ‡é’ˆï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰

### 2. å‡½æ•°è°ƒç”¨å®ç°

**æ–‡ä»¶**: `src/ir/ir_generator.cpp` - `visit(CallExpr*)`

```cpp
for (const auto &arg : node->arguments) {
    arg->accept(this);
    std::string arg_value = get_expr_result(arg.get());
    std::string arg_type_str = type_mapper_.map(arg->type.get());

    // æ£€æŸ¥æ˜¯å¦ä¸ºèšåˆç±»å‹
    bool is_aggregate = (arg->type->kind == TypeKind::ARRAY ||
                         arg->type->kind == TypeKind::STRUCT);

    if (is_aggregate) {
        args.push_back({arg_type_str + "*", arg_value});  // ä¼ æŒ‡é’ˆ
    } else {
        args.push_back({arg_type_str, arg_value});        // ä¼ å€¼
    }
}
```

### 3. è¿”å›å€¼å¤„ç†å®ç°

**å‡½æ•°è¿”å›å‰**:

```cpp
// æ£€æŸ¥è¿”å›ç±»å‹æ˜¯å¦ä¸ºèšåˆç±»å‹
bool ret_is_aggregate = (resolved->kind == TypeKind::ARRAY ||
                         resolved->kind == TypeKind::STRUCT);

// èšåˆç±»å‹è¿”å›å€¼ï¼šéœ€è¦loadæ•´ä¸ªå€¼
if (ret_is_aggregate) {
    std::string loaded_value = emitter_.emit_load(ret_type_str, body_result);
    emitter_.emit_ret(ret_type_str, loaded_value);
} else {
    emitter_.emit_ret(ret_type_str, body_result);
}
```

**è°ƒç”¨æ–¹æ¥æ”¶**:

```cpp
std::string result = emitter_.emit_call(ret_type_str, func_name, args);

if (ret_is_aggregate) {
    // ä¸ºè¿”å›å€¼åˆ†é…ç©ºé—´
    std::string alloca_ptr = emitter_.emit_alloca(ret_type_str);
    // å­˜å‚¨è¿”å›çš„èšåˆå€¼
    emitter_.emit_store(ret_type_str, result, alloca_ptr);
    // è¿”å›æŒ‡é’ˆï¼ˆä¿æŒä¸ArrayLiteral/StructInitializerä¸€è‡´ï¼‰
    store_expr_result(node, alloca_ptr);
} else {
    store_expr_result(node, result);
}
```

### 4. æ•°ç»„åˆå§‹åŒ–è¯­æ³•å®ç°

**æ–‡ä»¶**: `src/ir/ir_generator.cpp` - `visit(ArrayInitializerExpr*)`

**å…³é”®ç­–ç•¥**:

```cpp
const size_t UNROLL_THRESHOLD = 16;  // å±•å¼€é˜ˆå€¼

if (array_size <= UNROLL_THRESHOLD) {
    // å°æ•°ç»„ï¼šå±•å¼€ä¸ºå¤šä¸ªstore
    for (size_t i = 0; i < array_size; ++i) {
        std::vector<std::string> indices = {"i64 0", "i64 " + std::to_string(i)};
        std::string elem_ptr =
            emitter_.emit_getelementptr_inbounds(array_ir_type, array_ptr, indices);
        emitter_.emit_store(elem_ir_type, init_value, elem_ptr);
    }
} else {
    // å¤§æ•°ç»„ï¼šç”Ÿæˆå¾ªç¯
    // ä¼ªä»£ç :
    // i = 0
    // loop:
    //   if i >= size: break
    //   arr[i] = value
    //   i = i + 1
    //   goto loop
}
```

**LetStmt é›†æˆ**:

```cpp
// æ£€æŸ¥æ˜¯å¦æ˜¯æ•°ç»„å­—é¢é‡ã€æ•°ç»„åˆå§‹åŒ–å™¨æˆ–ç»“æ„ä½“åˆå§‹åŒ–å™¨
bool is_literal = (dynamic_cast<ArrayLiteralExpr *>(init_expr.get()) ||
                   dynamic_cast<ArrayInitializerExpr *>(init_expr.get()) ||  // æ–°å¢
                   dynamic_cast<StructInitializerExpr *>(init_expr.get()));
```

---

## ğŸ“Š æµ‹è¯•è¦†ç›–

### å‡½æ•°å‚æ•°/è¿”å›å€¼æµ‹è¯•

**æ–‡ä»¶**: `test1/ir/ir_generator/test_function_params.rs`

| æµ‹è¯•å‡½æ•°       | åŠŸèƒ½                      | çŠ¶æ€ |
| -------------- | ------------------------- | ---- |
| `sum_array`    | æ•°ç»„å‚æ•°ä¼ é€’              | âœ…   |
| `get_distance` | ç»“æ„ä½“å‚æ•°ä¼ é€’            | âœ…   |
| `add_points`   | å¤šä¸ªèšåˆå‚æ•° + è¿”å›ç»“æ„ä½“ | âœ…   |
| `create_array` | è¿”å›æ•°ç»„                  | âœ…   |
| `create_point` | è¿”å›ç»“æ„ä½“                | âœ…   |
| `double_point` | ä¼ é€’å¹¶è¿”å›ç»“æ„ä½“          | âœ…   |

**éªŒè¯ç»“æœ**: âœ… é€šè¿‡ llvm-as éªŒè¯

### æ•°ç»„åˆå§‹åŒ–è¯­æ³•æµ‹è¯•

**æ–‡ä»¶**: `test1/ir/ir_generator/test_array_init_syntax.rs`

| æµ‹è¯•å‡½æ•°                   | åŠŸèƒ½              | IR ç­–ç•¥          | çŠ¶æ€ |
| -------------------------- | ----------------- | ---------------- | ---- |
| `test_repeat_init_basic`   | `[0; 5]` åˆå§‹åŒ–   | å±•å¼€ 5 ä¸ª store  | âœ…   |
| `test_repeat_init_nonzero` | `[42; 10]` åˆå§‹åŒ– | å±•å¼€ 10 ä¸ª store | âœ…   |
| `test_repeat_init_large`   | `[7; 100]` åˆå§‹åŒ– | å¾ªç¯åˆå§‹åŒ–       | âœ…   |
| `test_modify_repeat_init`  | ä¿®æ”¹åˆå§‹åŒ–æ•°ç»„    | å±•å¼€+ä¿®æ”¹        | âœ…   |
| `test_mixed_init`          | æ··åˆä¸¤ç§åˆå§‹åŒ–    | åˆ—è¡¨+é‡å¤        | âœ…   |

**éªŒè¯ç»“æœ**: âœ… é€šè¿‡ llvm-as éªŒè¯

### å›å½’æµ‹è¯•

**åŸæœ‰æµ‹è¯•å¥—ä»¶**:

```
âœ… Phase 1: åŸºç¡€åŠŸèƒ½ v1, v2
âœ… Phase 2A: ifè¡¨è¾¾å¼ v1, v2
âœ… Phase 2B: while/loop v1, v2
âœ… Phase 2C: ç»¼åˆç®—æ³•
âœ… Phase 2D: æ•°ç»„å’Œç»“æ„ä½“
```

**æ€»è®¡**: 9/9 æµ‹è¯•å¥—ä»¶ï¼Œ100% é€šè¿‡ç‡

---

## ğŸ¨ ä»£ç è´¨é‡

### è®¾è®¡ä¼˜ç‚¹

1. **æ€§èƒ½ä¼˜åŒ–**: èšåˆç±»å‹æŒ‡é’ˆä¼ é€’é¿å…å¤§å¯¹è±¡æ‹·è´
2. **è‡ªé€‚åº”ç­–ç•¥**: æ•°ç»„åˆå§‹åŒ–æ ¹æ®å¤§å°é€‰æ‹©å±•å¼€æˆ–å¾ªç¯
3. **ä¸€è‡´æ€§**: æ‰€æœ‰èšåˆç±»å‹è¡¨è¾¾å¼è¿”å›æŒ‡é’ˆï¼Œè¯­ä¹‰ç»Ÿä¸€
4. **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„èšåˆç±»å‹ï¼ˆå¦‚å…ƒç»„ï¼‰

### ä»£ç ç»„ç»‡

- **å‚æ•°ä¼ é€’é€»è¾‘**: é›†ä¸­åœ¨`visit_function_decl()`
- **è¿”å›å€¼å¤„ç†**: åˆ†ç¦»å‡½æ•°å®šä¹‰å’Œè°ƒç”¨æ–¹å¤„ç†
- **æ•°ç»„åˆå§‹åŒ–**: ç‹¬ç«‹çš„`visit(ArrayInitializerExpr*)`å®ç°
- **LetStmt é›†æˆ**: æœ€å°åŒ–ä¿®æ”¹ï¼Œä»…å¢åŠ ç±»å‹æ£€æŸ¥

---

## ğŸ”® æœªæ¥ä¼˜åŒ–æ–¹å‘

### 1. alloca æå‡æœºåˆ¶ï¼ˆå·²æ·»åŠ åŸºç¡€æ¶æ„ï¼‰

**ç°çŠ¶**: åŸºç¡€æ¶æ„å·²å®ç°ä½†ç¦ç”¨  
**é—®é¢˜**: ä¸´æ—¶å˜é‡ç¼–å·å†²çª  
**éœ€è¦**: é‡æ–°è®¾è®¡ä¸´æ—¶å˜é‡ç®¡ç†æˆ–ä½¿ç”¨ two-pass ç”Ÿæˆ

### 2. sretï¼ˆç»“æ„åŒ–è¿”å›å€¼ï¼‰

**ç°çŠ¶**: ä½¿ç”¨ load/store æœºåˆ¶  
**ä¼˜åŒ–**: ä½¿ç”¨ LLVM sret å‚æ•°å±æ€§  
**å¥½å¤„**: æ›´ç¬¦åˆ ABI è§„èŒƒï¼Œæ€§èƒ½æ›´ä¼˜

### 3. memset ä¼˜åŒ–

**ç°çŠ¶**: å¤§æ•°ç»„ä½¿ç”¨å¾ªç¯åˆå§‹åŒ–  
**ä¼˜åŒ–**: å¯¹äºé›¶åˆå§‹åŒ–ï¼Œå¯è°ƒç”¨ LLVM memset  
**å¥½å¤„**: åˆ©ç”¨ç¡¬ä»¶åŠ é€Ÿï¼Œæ€§èƒ½æå‡

### 4. åµŒå¥—èšåˆç±»å‹

**ç¤ºä¾‹**: `[[i32; 3]; 3]`, `struct { arr: [i32; 10] }`  
**çŠ¶æ€**: åŸºç¡€è®¾æ–½å·²æ”¯æŒï¼Œéœ€è¦æµ‹è¯•éªŒè¯

---

## ğŸ“ˆ æ€§èƒ½å½±å“

### ç¼–è¯‘æ—¶æ€§èƒ½

- **å°æ•°ç»„åˆå§‹åŒ–**: O(n) å±•å¼€ï¼Œæ— é¢å¤–å¼€é”€
- **å¤§æ•°ç»„åˆå§‹åŒ–**: O(1) å¾ªç¯ç”Ÿæˆï¼Œæå°å¼€é”€
- **å‡½æ•°è°ƒç”¨**: å‚æ•°å¤„ç†å¢åŠ ç±»å‹æ£€æŸ¥ï¼Œå¯å¿½ç•¥

### è¿è¡Œæ—¶æ€§èƒ½

- **å‚æ•°ä¼ é€’**: é¿å…å¤§å¯¹è±¡æ‹·è´ï¼Œæ˜¾è‘—æå‡
- **è¿”å›å€¼**: éœ€è¦ä¸€æ¬¡é¢å¤–çš„ load/storeï¼Œç•¥æœ‰å¼€é”€
- **æ•°ç»„åˆå§‹åŒ–**:
  - å°æ•°ç»„ï¼šä¸æ‰‹åŠ¨åˆå§‹åŒ–ç›¸åŒ
  - å¤§æ•°ç»„ï¼šå¾ªç¯é«˜æ•ˆï¼Œè¿œä¼˜äºå±•å¼€

---

## âœ… æ€»ç»“

**Phase 2F æˆåŠŸå®ç°äº†**:

1. âœ… èšåˆç±»å‹å‡½æ•°å‚æ•°æŒ‡é’ˆä¼ é€’
2. âœ… èšåˆç±»å‹å‡½æ•°è¿”å›å€¼å¤„ç†
3. âœ… æ•°ç»„åˆå§‹åŒ–è¯­æ³• `[value; size]`
4. âœ… è‡ªé€‚åº”ä¼˜åŒ–ç­–ç•¥ï¼ˆå±•å¼€/å¾ªç¯ï¼‰
5. âœ… å®Œæ•´çš„æµ‹è¯•è¦†ç›–å’ŒéªŒè¯

**æµ‹è¯•ç»“æœ**:

- æ–°å¢æµ‹è¯•: 11 ä¸ªå‡½æ•°ï¼Œ100% é€šè¿‡
- å›å½’æµ‹è¯•: 9 ä¸ªæµ‹è¯•å¥—ä»¶ï¼Œ100% é€šè¿‡
- llvm-as éªŒè¯: å…¨éƒ¨é€šè¿‡

**ä»£ç è´¨é‡**:

- è®¾è®¡æ¸…æ™°ï¼ŒèŒè´£åˆ†æ˜
- æ˜“äºæ‰©å±•å’Œç»´æŠ¤
- æ€§èƒ½ä¼˜åŒ–åˆç†

---

**ä¸‹ä¸€æ­¥å»ºè®®**:

- è€ƒè™‘å®ç° sret ä¼˜åŒ–
- å®Œå–„ alloca æå‡æœºåˆ¶
- æ·»åŠ  memset é›¶åˆå§‹åŒ–ä¼˜åŒ–
- æµ‹è¯•åµŒå¥—èšåˆç±»å‹åœºæ™¯
