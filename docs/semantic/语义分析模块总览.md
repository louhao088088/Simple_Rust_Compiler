# 语义分析模块总览

## 模块的本质作用

语义分析是编译器前端的最后一个阶段,它的核心使命是**验证程序在语义层面的正确性**。虽然语法分析已经确保了程序符合语法规则,但这还不够——一个语法正确的程序可能在语义上完全错误。比如,给一个整数变量赋值字符串,或者调用一个不存在的函数,这些都是语法分析无法检测的错误。

语义分析模块要回答三个核心问题:

1. **这个名字是什么?** (名称解析) - 当代码中出现`x`时,它指的是哪个变量?在哪里定义的?
2. **这个东西是什么类型?** (类型解析和推导) - 每个表达式的类型是什么?能否自动推导?
3. **这个操作合法吗?** (类型检查) - 能否对这两个类型执行加法?能否给这个变量赋值?

## 模块的整体架构

语义分析模块采用**多遍扫描(Multi-pass)架构**,每一遍专注于解决一个特定的问题。这种设计的好处是每个阶段职责单一、逻辑清晰,缺点是需要多次遍历 AST。对于小型编译器来说,清晰性远比性能重要。

### 第一遍:名称解析(Name Resolution)

这一遍的目标是建立**名字到定义的映射**。想象你在阅读一本书,遇到"他说"这样的代词,你需要向前查找最近的男性人物是谁。名称解析做的就是这件事——它维护一个符号表,记录每个作用域中定义了哪些变量、函数、类型,当遇到变量使用时,就在符号表中查找对应的定义。

名称解析要处理的难点包括:

- **作用域嵌套**: 内层作用域可以访问外层的符号,但外层无法访问内层
- **变量遮蔽(Shadowing)**: Rust 允许在内层作用域重新定义同名变量,要正确处理这种情况
- **前向引用**: 函数可以调用后面定义的函数(需要先收集所有定义)
- **命名空间分离**: Rust 有值命名空间(变量、函数)和类型命名空间(结构体、枚举),互不冲突

### 第二遍:类型解析(Type Resolution)

这一遍将**类型注解(TypeNode)转换为类型对象(Type)**。AST 中的类型节点只是语法层面的描述,比如`Vec<i32>`只是三个 Token 的组合,类型解析要将其转换为真正的类型对象,查找`Vec`的定义,实例化泛型参数等。

类型解析的关键任务:

- **查找类型定义**: `Point`这个类型注解对应哪个结构体定义?
- **解析复合类型**: `[i32; 10]`要创建一个数组类型对象,元素类型是`i32`,大小是常量表达式`10`
- **计算数组大小**: `[T; N]`中的`N`必须是编译期常量,要调用常量求值器计算
- **处理引用和指针**: `&T`、`&mut T`、`*const T`都有不同的类型对象

### 第三遍:类型检查(Type Checking)

这是最复杂的一遍,要为**每个表达式推导类型并验证操作合法性**。这一遍不仅要向上推导类型(从子表达式到父表达式),还要向下传播类型约束(从上下文到表达式)。

类型检查要解决的问题:

- **类型推导**: `let x = 42;`中`x`的类型是什么?`42`是什么类型?
- **类型统一**: `if cond { 1 } else { 2 }`的两个分支类型必须相同
- **运算符重载**: `+`对整数和指针有不同的语义,要根据操作数类型选择
- **可变性检查**: 赋值目标必须是可变左值,`&T`和`&mut T`的转换规则
- **函数调用**: 参数类型必须匹配,参数数量必须正确

### 辅助工具:常量求值(Constant Evaluation)

这是一个独立的子模块,在**编译期计算常量表达式的值**。它不是一个完整的遍历,而是按需调用的工具函数。主要用途:

- 数组类型的大小:`[i32; 10]`中的`10`
- const 常量的值:`const MAX: i32 = 100;`
- 枚举变体的判别值:`enum Color { Red = 1, Green = 2 }`

## 类型系统设计

### 类型的表示

类型系统采用**对象模型**,每种类型都是一个继承自`Type`基类的对象。这种设计的好处是可以用多态处理不同类型,缺点是需要动态分配和类型转换。

基本设计:

```
Type (抽象基类)
  ├─ PrimitiveType (基本类型: i32, bool, str等)
  ├─ ArrayType (数组类型: [T; N])
  ├─ StructType (结构体类型)
  ├─ EnumType (枚举类型)
  ├─ FunctionType (函数类型)
  ├─ ReferenceType (引用类型: &T, &mut T)
  ├─ RawPointerType (裸指针: *const T, *mut T)
  ├─ UnitType (单元类型: ())
  └─ NeverType (Never类型: !)
```

每个类型对象都有:

- `kind`: 类型的种类(枚举值,用于快速判断)
- `to_string()`: 生成类型的字符串表示,用于错误消息
- `equals()`: 判断两个类型是否相等,核心是类型检查的比较操作
- `members`: 类型的成员符号表(方法、关联函数等)

### anyint 类型的设计动机

整数类型推导是一个有趣的问题。考虑代码`let x = 42;`,这里`42`是什么类型?Rust 的规则是:

1. 如果没有类型注解,整数字面量初始类型是"待推导的整数"
2. 根据后续使用推导出具体类型,如`x + 1i32`推导出`x`是`i32`
3. 如果到函数结束都无法推导,默认为`i32`

本实现引入了`anyint`类型来表示"待推导的整数":

- `anyint`可以和任何具体整数类型(`i32`, `u32`, `isize`, `usize`)统一
- 当`anyint`和具体类型相遇,`anyint`"塌缩"为具体类型
- 两个`anyint`相遇,保持`anyint`,推迟决策

这种设计简化了实现,代价是类型推导不够完整。更复杂的实现会使用约束求解器。

### Never 类型的特殊性

`!`类型(Never type)表示"永不返回的计算",如`panic!()`、无限循环、`return`语句等。它有一个神奇的性质:**可以转换为任意类型**。这是为了让这样的代码类型正确:

```rust
let x: i32 = if condition { 42 } else { panic!("error") };
```

这里`then`分支是`i32`,`else`分支是`!`,整体类型是`i32`。Never 类型的`equals()`方法总是返回 true,实现了这个语义。

## 符号表的组织

符号表是名称解析的核心数据结构,它维护**作用域到符号的映射**。

### 符号表的结构

每个符号表包含一个**作用域栈**,每个作用域又包含两个独立的符号映射:

- **值符号表**: 存储变量、函数、常量等,对应值命名空间
- **类型符号表**: 存储结构体、枚举、类型别名等,对应类型命名空间

这种分离设计允许值和类型使用相同的名字而不冲突,如:

```rust
struct Foo { }  // 在类型命名空间
let Foo = 42;   // 在值命名空间,不冲突
```

### 作用域的生命周期

作用域遵循**栈的生命周期**:

- 进入块语句时`enter_scope()`,创建新作用域压栈
- 离开块语句时`exit_scope()`,弹出当前作用域
- 查找符号时从栈顶向栈底搜索,找到第一个匹配即返回

这自然实现了变量遮蔽:内层定义遮蔽外层同名定义,因为查找时先找到内层的。

### 符号的属性

每个符号记录了:

- `name`: 符号的名字
- `kind`: 符号的种类(变量、函数、类型、常量等)
- `type`: 符号的类型
- `is_mutable`: 是否可变(用于变量)
- `is_builtin`: 是否是内置符号
- `members`: 符号的成员(用于模块、类型等)
- `const_decl_node`: 常量的 AST 节点(用于常量求值)

## 访问者模式的应用

语义分析大量使用**访问者模式(Visitor Pattern)**遍历 AST。这种模式的核心思想是**将算法和数据结构分离**:

- AST 节点只负责存储数据,不包含分析逻辑
- 每种分析算法实现为一个 Visitor,包含访问每种节点的`visit()`方法
- 遍历时调用`node->accept(visitor)`,节点根据自己的类型调用对应的`visit()`方法

这种设计的优势:

1. **易于扩展**: 添加新的分析只需实现新的 Visitor,不用修改 AST 节点
2. **逻辑集中**: 同一种分析的代码集中在一个 Visitor 类中
3. **类型安全**: 通过多态实现动态分发,编译期类型检查

本项目实现了四个主要的 Visitor:

- `NameResolutionVisitor`: 名称解析,建立符号表
- `TypeResolver`: 类型解析,将 TypeNode 转换为 Type 对象
- `TypeCheckVisitor`: 类型检查,推导表达式类型并验证
- `ConstEvaluator`: 常量求值,计算编译期常量

## 错误处理策略

语义分析的错误处理采用**收集式报告(Collecting Errors)**策略:

- 遇到错误时记录到`ErrorReporter`,但不立即停止
- 尽可能继续分析,发现更多错误
- 所有 Pass 运行完后,统一检查是否有错误

这种策略的好处是**一次编译发现多个错误**,提高开发效率。代价是要小心处理错误状态,避免级联错误(一个错误导致大量后续误报)。

实现技巧:

- 遇到错误时为节点填充空类型或默认类型,避免空指针
- 检查操作数是否为空,空则跳过后续检查
- 错误恢复:在合适的位置(如语句边界)重置状态

## 内置类型和函数

编译器在语义分析开始前**预定义了内置类型和函数**,这样用户代码可以直接使用它们而无需声明。

### 内置类型

基本类型:

- 整数类型:`i32`, `u32`, `isize`, `usize`
- 布尔类型:`bool`
- 字符类型:`char`
- 字符串类型:`str`, `String`
- 特殊类型:`anyint`(类型推导用)

这些类型在`define_builtin_functions()`中注册到符号表。

### 内置函数

为了让测试程序能够进行输入输出,预定义了一些内置函数:

- `print(s: &str)`: 打印字符串(不换行)
- `println(s: &str)`: 打印字符串(换行)
- `printInt(n: i32)`: 打印整数
- `printlnInt(n: i32)`: 打印整数(换行)
- `getInt() -> i32`: 读取整数
- `getString() -> String`: 读取字符串
- `exit(code: i32)`: 退出程序

这些函数都标记为`is_builtin = true`,在代码生成阶段会特殊处理(调用运行时库或生成内联代码)。

### 内置方法

为了支持方法调用,某些类型预定义了方法:

- `u32::to_string(&self) -> String`: 整数转字符串
- `String::as_str(&self) -> &str`: 获取字符串切片
- `String::from(&str) -> String`: 从切片创建 String
- `str::len(&self) -> usize`: 获取字符串长度

这些方法添加到类型对象的`members`符号表中。类型检查字段访问或方法调用时,会在`type->members`中查找。

## 模块间的协作

四个子模块不是孤立工作的,它们之间有复杂的协作关系:

### NameResolutionVisitor ← TypeResolver

名称解析需要类型解析的帮助:

- 解析`let x: i32 = ...;`时,要解析类型注解`i32`
- 创建`TypeResolver`实例,调用`resolve(type_node)`获取 Type 对象
- 将解析后的类型存入符号表,供后续类型检查使用

### TypeResolver → NameResolutionVisitor

类型解析也需要名称解析:

- 解析`PathTypeNode`(如`std::vec::Vec`)时,要查找路径中的符号
- 调用`NameResolutionVisitor`的方法解析路径表达式
- 从解析结果获取类型符号

### TypeCheckVisitor → ConstEvaluator

类型检查需要常量求值:

- 检查数组初始化器`[value; count]`时,要计算`count`的值
- 调用`ConstEvaluator::evaluate()`获取常量值
- 用常量值创建数组类型对象

### ConstEvaluator → 符号表

常量求值需要访问符号表:

- 计算`const MAX: i32 = 100; let arr = [0; MAX];`时,`MAX`是一个常量
- 从符号表查找`MAX`的定义,获取其`const_decl_node`
- 递归求值常量定义的表达式

这种相互依赖通过**依赖注入**解决:每个模块持有其他模块的引用,但避免循环依赖。

## 分析的执行顺序

语义分析的入口是`Semantic()`函数,它按照精心设计的顺序执行各个阶段:

```
1. 创建全局符号表
2. 定义内置类型(i32, bool等)
3. 定义内置函数(print, println等)
4. 定义内置方法(to_string, len等)
5. 创建NameResolutionVisitor
6. 遍历AST进行名称解析(第一遍)
7. 创建TypeCheckVisitor
8. 遍历AST进行类型检查(第二遍)
9. 检查错误,返回结果
```

这个顺序不能随意改变:

- 内置符号必须先定义,否则代码中的`i32`、`print`等会报未定义错误
- 名称解析必须先于类型检查,因为类型检查需要符号表信息
- 类型解析嵌入在名称解析中,因为符号定义时就要确定类型

## 与 AST 的交互

语义分析不修改 AST 的结构,但会**填充 AST 节点的语义属性**:

### Expr 节点的填充

- `type`: 表达式的类型,由 TypeCheckVisitor 填充
- `resolved_symbol`: 引用的符号,由 NameResolutionVisitor 填充
- `is_mutable_lvalue`: 是否为可变左值,由 TypeCheckVisitor 填充
- `return_over`: 是否必然返回,用于检查函数返回路径

### TypeNode 节点的填充

- `resolved_symbol`: 类型名对应的符号,由 TypeResolver 填充
- `resolved_type`: 解析后的类型对象,由 TypeResolver 填充

### Item 节点的填充

- `resolved_symbol`: 声明引入的符号,由 NameResolutionVisitor 填充

这些填充的信息供后续阶段(如代码生成)使用,也可以用于 IDE 的语义高亮、跳转定义等功能。

## 局限性和改进方向

当前实现是一个**教学性的简化版本**,与完整的 Rust 编译器相比有诸多局限:

### 类型推导的局限

- 只支持简单的整数类型推导,不支持函数参数、返回值的推导
- 没有实现双向类型检查(bidirectional type checking)
- 没有约束求解器,无法处理复杂的类型约束

### 缺失的语义特性

- 生命周期系统:Rust 的核心特性,本实现完全未涉及
- Trait 系统:泛型、trait 约束、trait 对象等
- 宏系统:过程宏、声明宏的展开和检查
- 模式匹配的完整性检查:检查是否覆盖所有情况
- 借用检查:可变性检查只是浅层的,未实现完整的借用规则

### 错误报告的不足

- 错误消息比较简单,缺少上下文信息
- 没有建议(suggestions),无法提示用户如何修复
- 没有错误码,难以查找文档

### 性能问题

- 多遍扫描效率较低,完整编译器通常一遍完成
- 类型对象使用 shared_ptr,内存开销较大
- 没有增量编译支持,每次都全量分析

尽管有这些局限,这个实现已经足够演示编译器前端的核心概念,并且代码质量较高,适合学习。

## 总结

语义分析是编译器前端的核心,它连接了语法分析和代码生成,为程序赋予了"意义"。通过名称解析、类型解析、类型检查三个阶段的协作,将语法正确的 AST 转换为语义正确、类型标注完整的 AST。

设计要点:

- **多遍扫描**:每遍专注一个任务,逻辑清晰
- **符号表**:维护作用域和符号的映射,支持嵌套和遮蔽
- **类型系统**:对象模型表示类型,支持复杂的类型结构
- **访问者模式**:分离算法和数据,易于扩展
- **错误收集**:尽可能发现多个错误,提高开发效率

理解语义分析,就理解了编译器如何"理解"程序。这是从符号操作到语义推理的飞跃,是编译原理最迷人的部分。
