# 类型检查器详解

## 类型检查的哲学意义

类型检查不只是验证类型是否匹配,它体现了一个深刻的思想:**用静态分析消除运行时错误**。每一次类型检查,都是在编译期回答这样的问题:"这段代码运行时会出错吗?"

考虑这个简单的加法:`a + b`。如果`a`是整数,`b`是字符串,运行时会发生什么?可能崩溃,可能产生垃圾数据,可能触发未定义行为。类型检查在编译期发现这个问题,强制程序员修复,避免了运行时的灾难。

但类型检查不只是说"不",它还要说"是什么"。每个表达式的类型是什么?能否自动推导?这些问题的答案,就是类型检查器的输出——一个完全标注类型的 AST。

## 类型推导的双向性

### 向上推导:从叶到根

最直观的类型推导是**自底向上**的:先推导子表达式的类型,再推导父表达式的类型。

例如`1 + 2`:

1. `1`是字面量,类型是 anyint(待推导的整数)
2. `2`也是 anyint
3. `+`要求两个操作数类型相同,anyint + anyint → anyint
4. 整个表达式的类型是 anyint

这种推导是**综合(Synthesis)**的:从已知推导未知,从部分构建整体。

### 向下传播:从根到叶

但有些情况需要**自顶向下**的类型传播:

```rust
let x: i32 = if cond { 1 } else { 2 };
```

这里:

1. `x`的类型注解是`i32`,这是已知的
2. 赋值要求右边的类型是`i32`,这是向下的约束
3. if 表达式要返回`i32`,约束传给两个分支
4. 分支中的`1`和`2`原本是 anyint,现在被约束为`i32`

这种传播是**检查(Checking)**的:从期望验证实际,从整体约束部分。

### 双向类型检查

理想的类型系统应该结合两种方向,这叫**双向类型检查(Bidirectional Type Checking)**:

- 某些位置用综合:推导出类型
- 某些位置用检查:验证期望类型

但当前实现**主要是综合式的**,简化了设计。期望类型主要通过类型统一(Unification)实现:两个类型必须相同,如果一个是 anyint,就"塌缩"为另一个。

## 整数类型推导的机制

### anyint 类型的引入

Rust 允许整数字面量不带类型后缀:

```rust
let x = 42;     // 42的类型是什么?
let y: i32 = x; // 现在知道x是i32
```

如果`42`一开始就被标记为`i32`,那`let y: u32 = 42;`就会出错。但 Rust 允许这样,说明字面量的类型是"待定的"。

解决方案是**anyint 类型**:表示"某种整数类型,但还不确定是哪种"。它的特殊性质:

- anyint 可以和任何具体整数类型(i32, u32, isize, usize)统一
- anyint 和 anyint 统一,仍是 anyint(推迟决策)
- 如果到最后还是 anyint,默认为 i32

### 类型统一的实现

二元运算时,两个操作数的类型要"统一"为一个类型:

```cpp
// 加法运算的类型检查
if (left_is_int && right_is_int) {
    if (is_concrete_integer(left_type->kind)) {
        // 左侧是具体类型(i32, u32等)
        if (is_concrete_integer(right_type->kind)) {
            // 右侧也是具体类型,必须相同
            if (left_type->equals(right_type.get())) {
                node->type = left_type;  // 结果是共同类型
            } else {
                report_error("Mismatched integer types.");
            }
        } else {
            // 右侧是anyint,统一为左侧的类型
            node->type = left_type;
        }
    } else if (is_concrete_integer(right_type->kind)) {
        // 左侧是anyint,右侧是具体类型,统一为右侧
        node->type = right_type;
    } else {
        // 两侧都是anyint,结果是anyint
        node->type = make_shared<PrimitiveType>(TypeKind::ANY_INTEGER);
    }
}
```

这个逻辑体现了类型统一的规则:

1. 具体类型 + 具体类型 → 必须相同,否则错误
2. 具体类型 + anyint → 具体类型(anyint 塌缩)
3. anyint + anyint → anyint(继续待定)

通过这种机制,`let x = 1; let y: i32 = x + 2;`会正确推导:`1`是 anyint,`2`是 anyint,`x + 2`是 anyint,赋值给`i32`时 anyint 塌缩为 i32。

### 局限性:不够完整

当前实现的类型推导是**局部的**:只在单个表达式内统一类型,不跨表达式传播。

这导致一些合法的 Rust 代码无法编译:

```rust
let x = 42;        // x是anyint
let y = x;         // y也是anyint
let z: i32 = y;    // z是i32,但x和y仍是anyint?
```

完整的实现需要**全局类型推导**:收集所有类型约束,求解约束系统,统一推导所有变量的类型。这需要复杂的算法(如 Hindley-Milner 类型推导),超出了教学编译器的范围。

## 运算符重载的处理

### 算术运算符的多态

`+`运算符在 Rust 中有多种语义:

1. 整数加法:`i32 + i32 → i32`
2. 指针偏移:`*const T + usize → *const T`
3. 字符串拼接(通过 trait,当前未实现)

类型检查要根据操作数类型**选择正确的语义**:

```cpp
case TokenType::PLUS: {
    // 情况1:指针 + 整数
    if (is_raw_pointer(left_type) && is_size_integer(right_type)) {
        node->type = left_type;  // 结果是指针类型
        return nullptr;
    }

    // 情况2:整数 + 指针(交换律)
    if (is_size_integer(left_type) && is_raw_pointer(right_type)) {
        node->type = right_type;
        return nullptr;
    }

    // 情况3:整数 + 整数
    bool left_is_int = is_any_integer_type(left_type->kind);
    bool right_is_int = is_any_integer_type(right_type->kind);
    if (left_is_int && right_is_int) {
        // ... 类型统一逻辑
    } else {
        report_error("Invalid operands for +.");
    }
}
```

这是一个经典的**多态分发(Polymorphic Dispatch)**:根据参数类型选择不同的处理逻辑。类型检查器充当了"调度员"的角色。

### 比较运算符的约束

比较运算符有更复杂的约束:不是所有类型都能比较,能比较的类型也有限制。

```cpp
case TokenType::LESS: {
    bool left_is_int = is_any_integer_type(left_type->kind);
    bool right_is_int = is_any_integer_type(right_type->kind);

    if (left_is_int && right_is_int) {
        node->type = make_shared<PrimitiveType>(TypeKind::BOOL);
    } else {
        report_error("Comparison operators require integer operands.");
    }
}
```

这里的设计决策是:**只允许整数之间的大小比较**。字符串、布尔值等不能用`<`比较(虽然 Rust 通过 trait 可以)。这简化了实现,对教学目的足够。

等值比较`==`和`!=`则更宽松,允许整数、布尔值、引用、字符、字符串等:

```cpp
case TokenType::EQUAL_EQUAL: {
    bool is_valid = false;

    // 整数可以比较
    if (is_any_integer_type(left_type->kind) &&
        is_any_integer_type(right_type->kind)) {
        is_valid = true;
    }
    // 布尔值可以比较
    else if (left_type->kind == TypeKind::BOOL &&
             right_type->kind == TypeKind::BOOL) {
        is_valid = true;
    }
    // 引用可以比较(比较地址)
    else if (left_type->kind == TypeKind::REFERENCE &&
             right_type->kind == TypeKind::REFERENCE) {
        if (left_type->equals(right_type.get())) {
            is_valid = true;
        }
    }
    // ... 其他类型

    if (is_valid) {
        node->type = make_shared<PrimitiveType>(TypeKind::BOOL);
    } else {
        report_error("Invalid operands for equality comparison.");
    }
}
```

这种**白名单(Whitelist)**策略明确列出了允许的类型组合,拒绝其他情况。相比黑名单,更安全但更保守。

## 数组类型的复杂性

### 数组字面量的类型推导

数组字面量`[1, 2, 3]`的类型推导要处理两个问题:

1. **元素类型统一**:所有元素必须是同一类型
2. **数组大小计算**:长度是元素个数

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(ArrayLiteralExpr *node) {
    if (node->elements.empty()) {
        error_reporter_.report_error("Cannot infer type of empty array.");
        return nullptr;
    }

    // 1. 先推导所有元素的类型
    for (auto &element : node->elements) {
        element->accept(this);
    }

    // 2. 确定数组的元素类型
    shared_ptr<Type> array_element_type = node->elements[0]->type;

    // 如果第一个元素是anyint,尝试从后续元素推导具体类型
    if (array_element_type->kind == TypeKind::ANY_INTEGER) {
        for (const auto &element : node->elements) {
            if (is_concrete_integer(element->type->kind)) {
                array_element_type = element->type;
                break;
            }
        }
    }

    // 3. 验证所有元素类型一致
    for (const auto &element : node->elements) {
        if (!array_element_type->equals(element->type.get())) {
            report_error("Mismatched types in array literal.");
            return nullptr;
        }
    }

    // 4. 创建数组类型
    size_t array_size = node->elements.size();
    node->type = make_shared<ArrayType>(array_element_type, array_size);

    return nullptr;
}
```

这个过程体现了类型推导的**策略选择**:

- 先用第一个元素的类型作为候选
- 如果是 anyint,尝试找一个具体类型(因为具体类型更确定)
- 验证所有元素都匹配这个类型

这种策略让`[1, 2, 3]`推导为`[anyint; 3]`,但`[1i32, 2, 3]`推导为`[i32; 3]`,后者更精确。

### 数组初始化器的常量求值

数组初始化器`[value; count]`要求`count`是**编译期常量**,这是 Rust 的语法要求,也是内存分配的需要(编译期要知道数组大小)。

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(ArrayInitializerExpr *node) {
    // 1. 推导value的类型
    node->value->accept(this);
    shared_ptr<Type> element_type = node->value->type;
    if (!element_type) {
        return nullptr;
    }

    // 2. 求值count表达式,必须是常量
    ConstEvaluator const_evaluator(symbol_table_, error_reporter_);
    auto size_opt = const_evaluator.evaluate(node->size.get());

    if (!size_opt) {
        error_reporter_.report_error("Array size must be a compile-time constant.");
        return nullptr;
    }

    // 3. 验证大小非负
    long long evaluated_size = *size_opt;
    if (evaluated_size < 0) {
        error_reporter_.report_error("Array size cannot be negative.");
        return nullptr;
    }

    // 4. 创建数组类型
    size_t array_size = static_cast<size_t>(evaluated_size);
    node->type = make_shared<ArrayType>(element_type, array_size);

    return nullptr;
}
```

这里展示了类型检查和常量求值的**协作**:类型检查需要常量求值的结果(数组大小),常量求值需要类型检查的结果(变量的类型)。两者相互依赖,通过按需调用解决。

关键设计:

- `ConstEvaluator`返回`optional<long long>`,空值表示求值失败(不是常量)
- 负数检查是语义约束,不是语法约束
- 用`size_t`存储大小,避免负数,但要先检查以报告友好错误

## 函数调用的类型检查

### 参数匹配的多维验证

函数调用`f(a, b, c)`的类型检查要验证:

1. `f`是可调用的(函数类型)
2. 参数数量匹配
3. 每个参数的类型匹配

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(CallExpr *node) {
    // 1. 推导被调用表达式的类型
    node->callee->accept(this);
    auto callee_type = node->callee->type;

    // 2. 验证是函数类型
    auto *func_type = dynamic_cast<FunctionType *>(callee_type.get());
    if (!func_type) {
        error_reporter_.report_error("Expression is not callable.");
        return nullptr;
    }

    // 3. 检查参数数量
    if (node->arguments.size() != func_type->param_types.size()) {
        error_reporter_.report_error(
            "Expected " + to_string(func_type->param_types.size()) +
            " arguments, got " + to_string(node->arguments.size())
        );
        return nullptr;
    }

    // 4. 推导所有参数的类型
    for (auto &arg : node->arguments) {
        arg->accept(this);
    }

    // 5. 逐个检查参数类型
    for (size_t i = 0; i < node->arguments.size(); ++i) {
        auto arg_type = node->arguments[i]->type;
        auto param_type = func_type->param_types[i];

        if (!arg_type || !param_type->equals(arg_type.get())) {
            error_reporter_.report_error(
                "Argument " + to_string(i) + " type mismatch. Expected " +
                param_type->to_string() + ", got " +
                (arg_type ? arg_type->to_string() : "unknown")
            );
        }
    }

    // 6. 调用表达式的类型是返回类型
    node->type = func_type->return_type;

    return nullptr;
}
```

这个过程体现了类型检查的**层次性**:先检查大结构(是否可调用),再检查细节(参数类型)。每一层都可能失败,要优雅处理。

注意参数类型检查不会提前返回:即使第一个参数类型错误,也继续检查后续参数,一次性报告所有错误。这是**错误收集**策略的应用。

### 方法调用的特殊处理

方法调用`obj.method(args)`在 AST 中表示为`CallExpr(FieldAccessExpr(obj, method), args)`,类型检查时要:

1. 推导`obj`的类型
2. 在`obj.type->members`中查找`method`
3. 验证`method`是函数类型
4. 检查参数类型(包括隐式的`self`参数)

但当前实现**简化了方法调用**:假设`FieldAccessExpr`已经在名称解析时绑定了符号,类型检查只需推导`CallExpr`。完整实现需要处理`self`参数的隐式传递、方法的可见性等。

## 左值和可变性检查

### 什么是左值?

左值(Lvalue)是"可以出现在赋值号左边的表达式",更准确的定义是:**表示内存位置的表达式**。

Rust 的左值包括:

- 变量:`x`
- 解引用:`*ptr`
- 数组索引:`arr[i]`
- 字段访问:`obj.field`

非左值包括:

- 字面量:`42`
- 算术运算:`x + y`
- 函数调用:`f()`(除非返回引用)

### 可变左值的判定

赋值的目标必须是**可变左值(Mutable Lvalue)**,即:

1. 是左值(表示内存位置)
2. 可变(用`mut`声明,或是可变引用的解引用)

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(AssignmentExpr *node) {
    // 1. 推导目标和值的类型
    node->target->accept(this);
    node->value->accept(this);

    auto target_type = node->target->type;
    auto value_type = node->value->type;

    // 2. 检查目标是可变左值
    if (!node->target->is_mutable_lvalue) {
        error_reporter_.report_error(
            "Cannot assign to immutable variable or expression."
        );
        return nullptr;
    }

    // 3. 检查类型匹配
    if (!target_type || !value_type || !target_type->equals(value_type.get())) {
        error_reporter_.report_error("Type mismatch in assignment.");
        return nullptr;
    }

    // 4. 赋值表达式的类型是Unit
    node->type = make_shared<UnitType>();

    return nullptr;
}
```

关键是`is_mutable_lvalue`字段的设置:

**变量表达式**:

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(VariableExpr *node) {
    // ... 设置type

    // 检查可变性
    if (node->resolved_symbol && node->resolved_symbol->kind == Symbol::VARIABLE) {
        bool binding_is_mut = node->resolved_symbol->is_mutable;  // 绑定是否可变
        bool type_is_mut_ref = false;

        // 如果类型是可变引用,也是可变左值
        if (auto *ref_type = dynamic_cast<ReferenceType *>(node->type.get())) {
            type_is_mut_ref = ref_type->is_mutable;
        }

        node->is_mutable_lvalue = binding_is_mut || type_is_mut_ref;
    }
}
```

**解引用表达式**:

```cpp
case TokenType::STAR: {  // 解引用
    if (auto *ref_type = dynamic_cast<ReferenceType *>(operand_type.get())) {
        node->type = ref_type->referenced_type;
        node->is_mutable_lvalue = ref_type->is_mutable;  // 继承引用的可变性
    }
    // ...
}
```

这种设计让可变性信息在 AST 中**向上传播**:每个表达式节点知道自己是否为可变左值,父节点根据子节点判断。

## 控制流表达式的类型

### if 表达式的类型规则

if 表达式的类型规则比较复杂,取决于是否有 else 分支和是否带分号:

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(IfExpr *node) {
    // 1. 推导条件类型,必须是bool
    node->condition->accept(this);
    if (node->condition->type &&
        node->condition->type->kind != TypeKind::BOOL) {
        error_reporter_.report_error("If condition must be boolean.");
    }

    // 2. 推导then分支类型
    node->then_branch->accept(this);
    shared_ptr<Type> then_type = node->then_branch->type;

    // 3. 处理else分支(如果有)
    shared_ptr<Type> else_type;
    if (node->else_branch) {
        (*node->else_branch)->accept(this);
        else_type = (*node->else_branch)->type;

        // 4. 两个分支类型必须统一
        if (then_type && else_type) {
            if (!then_type->equals(else_type.get())) {
                error_reporter_.report_error(
                    "If branches have incompatible types: " +
                    then_type->to_string() + " vs " + else_type->to_string()
                );
                node->type = make_shared<UnitType>();
                return nullptr;
            }
            node->type = then_type;
        }
    } else {
        // 5. 无else分支,类型是Unit
        node->type = make_shared<UnitType>();
    }

    // 6. 带分号强制为Unit类型
    if (node->has_semicolon) {
        node->type = make_shared<UnitType>();
    }

    return nullptr;
}
```

这个逻辑体现了 Rust 的**表达式导向设计**:

- `if cond { 1 } else { 2 }` → 类型是 i32,可以作为表达式
- `if cond { 1 } else { 2 };` → 带分号,类型是(),值被丢弃
- `if cond { 1 }` → 无 else,类型是(),因为可能不执行 then 分支

### 循环表达式的 Never 类型

`loop`表达式理论上永不返回,所以类型是`!`(Never):

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(LoopExpr *node) {
    node->body->accept(this);

    // loop表达式的类型是Never,因为无限循环
    node->type = make_shared<NeverType>();

    return nullptr;
}
```

但如果 loop 中有`break value;`,整个 loop 表达式的类型是 break 的值类型。当前实现**未处理这种情况**,是一个简化。完整实现需要:

1. 收集所有 break 语句的值类型
2. 统一这些类型
3. 如果没有 break,类型是 Never

## 引用类型的处理

### 自动引用转换

Rust 有一个方便的特性:**自动引用转换(Auto-referencing)**。当调用方法时,编译器自动插入`&`或`&mut`:

```rust
let s = String::new();
s.len();  // 等价于 (&s).len()
```

但当前实现**不支持自动引用**,必须显式写`&s.len()`。这简化了类型检查,代价是代码不够简洁。

### 引用的创建和解引用

创建引用很直接:

```cpp
shared_ptr<Symbol> TypeCheckVisitor::visit(ReferenceExpr *node) {
    node->expression->accept(this);
    auto inner_type = node->expression->type;

    if (!inner_type) {
        return nullptr;
    }

    // &T 或 &mut T
    node->type = make_shared<ReferenceType>(inner_type, node->is_mutable);

    return nullptr;
}
```

解引用在一元运算符中处理,前面已经展示。

### 引用的可变性规则

Rust 的可变性规则:

1. 不可变引用可以有多个
2. 可变引用同时只能有一个
3. 不可变引用和可变引用不能共存

但这些规则需要**借用检查器(Borrow Checker)**来验证,涉及到生命周期分析。当前实现**完全未实现借用检查**,只做了简单的可变性检查。

这是最大的简化,也是 Rust 最独特的特性。完整实现需要:

- 生命周期标注和推导
- 借用关系图的构建
- 借用冲突检测
- 移动语义的检查

这些内容足以写一篇论文,超出了教学编译器的范围。

## 错误处理的细节

### 空类型的处理

类型推导可能失败(子表达式有错误),导致`type`字段为空。后续使用时要检查:

```cpp
if (!left_type || !right_type) {
    return nullptr;  // 子表达式有错,跳过检查
}
```

这避免了空指针解引用,也避免了级联错误。

### 类型比较的鲁棒性

类型比较要处理 Never 类型的特殊性:

```cpp
bool PrimitiveType::equals(const Type *other) const {
    if (other == nullptr) return false;

    TypeKind other_kind = other->kind;

    // Never类型可以转换为任意类型
    if (this->kind == TypeKind::NEVER || other_kind == TypeKind::NEVER) {
        return true;
    }

    // anyint类型可以和具体整数类型统一
    if (this->kind == TypeKind::ANY_INTEGER) {
        return is_concrete_integer(other_kind) ||
               other_kind == TypeKind::ANY_INTEGER;
    }

    if (other_kind == TypeKind::ANY_INTEGER) {
        return is_concrete_integer(this->kind);
    }

    // 其他情况,必须完全相同
    return this->kind == other_kind;
}
```

这个`equals`方法是类型检查的核心,体现了类型系统的所有特殊规则。

## 性能和正确性的权衡

### 多次遍历 vs 一次遍历

当前实现对每个表达式树进行一次遍历,推导所有节点的类型。这很直观,但效率不是最优:

- 递归函数调用开销
- 重复访问某些节点

更高效的实现会使用**迭代式数据流分析**:

- 维护一个工作列表
- 每次处理一个节点,更新其类型
- 类型改变时,将依赖节点加入工作列表
- 直到工作列表为空(不动点)

但这增加了复杂度,对教学编译器来说,清晰性优先。

### 精确性 vs 完整性

类型检查要在精确性和完整性之间权衡:

- **精确性**:报告的错误都是真实的(无误报)
- **完整性**:发现所有错误(无漏报)

理想情况两者兼顾,但往往需要取舍。当前实现倾向于**保守**:宁可漏报,不要误报。比如简化的 anyint 推导可能漏掉一些类型错误,但不会把正确代码标记为错误。

## 总结

类型检查是语义分析的核心,将无类型的 AST 转换为类型完备的 AST。它不只验证类型匹配,还要推导类型、统一类型、传播约束。

核心机制:

- **类型推导**:从已知推导未知,自底向上
- **类型统一**:合并类型约束,处理 anyint
- **运算符重载**:根据操作数类型选择语义
- **可变性检查**:维护并传播左值和可变性信息
- **错误收集**:尽可能发现多个错误,优雅处理失败

理解类型检查,就理解了编译器如何"理解"程序的类型结构,如何在编译期消除运行时错误。这是静态类型语言的核心价值。
