# 名称解析器详解

## 名称解析的本质问题

当你阅读一段代码,看到`x + y`这样的表达式,你的大脑会自动做一件事:向上扫描,找到`x`和`y`是在哪里定义的。这个看似简单的过程,就是名称解析器要完成的核心任务。但这个任务远比想象的复杂,因为要处理:

**作用域嵌套的复杂性**:一个名字可能在多个层次的作用域中被定义,要找到"最近"的那个。想象俄罗斯套娃,内层娃娃找东西时,要先在自己这层找,找不到再到外层找。

**变量遮蔽的微妙性**:Rust 允许内层作用域重新定义外层的名字,这时外层的定义被"遮蔽"。比如:

```rust
let x = 10;        // 外层的x
{
    let x = 20;    // 内层的x,遮蔽外层
    print(x);      // 输出20,使用内层的x
}
print(x);          // 输出10,外层的x重新可见
```

**命名空间的分离**:Rust 有两个独立的命名空间——值命名空间和类型命名空间。这意味着:

```rust
struct Point { x: i32 }  // Point在类型命名空间
let Point = 42;          // Point在值命名空间,不冲突!
let p: Point = Point { x: 0 };  // 前一个Point是类型,后一个Point可能是值
```

**前向引用的挑战**:函数可以调用后面定义的函数,这要求我们先收集所有定义,再解析引用。但 Rust 又不允许变量的前向引用,要区分这两种情况。

## 符号表的精巧设计

### 为什么需要两层结构?

符号表采用**双层映射**的设计:第一层是作用域栈,第二层是每个作用域内的符号映射。这种设计不是随意的,而是精心权衡的结果。

考虑这段代码:

```rust
let a = 1;
{
    let b = 2;
    {
        let c = 3;
        // 这里能访问a, b, c
    }
    // 这里能访问a, b,但不能访问c
}
// 这里只能访问a
```

如果用单层哈希表存储所有符号,退出作用域时如何知道要删除哪些符号?要么记录每个符号属于哪个作用域(复杂且低效),要么无法正确清理(内存泄漏)。

使用作用域栈,每个作用域是一个独立的符号表,退出作用域时直接弹栈,自动清理所有该作用域的符号。简洁且高效。

### 作用域的数据结构

每个作用域包含两个哈希表:

```cpp
struct Scope {
    unordered_map<string, shared_ptr<Symbol>> value_symbols;  // 值命名空间
    unordered_map<string, shared_ptr<Symbol>> type_symbols;   // 类型命名空间
};
```

为什么分成两个表?因为 Rust 允许值和类型重名。如果混在一个表里,就无法区分`Point`到底是结构体还是变量。分开存储,查找时根据上下文选择正确的命名空间。

### 符号对象的信息密度

每个符号不只是一个名字,而是一个信息丰富的对象:

```cpp
struct Symbol {
    string name;                      // 符号的名字
    SymbolKind kind;                  // 种类:变量、函数、类型等
    shared_ptr<Type> type;            // 符号的类型
    bool is_mutable;                  // 是否可变(变量专用)
    bool is_builtin;                  // 是否内置
    shared_ptr<SymbolTable> members;  // 成员符号表(模块、类型等)
    ConstDecl *const_decl_node;       // 常量定义的AST节点(常量专用)
};
```

每个字段都有其存在的理由:

**`kind`字段**:快速判断符号类型,避免向下类型转换。比如检查`Point { x: 1 }`时,要验证`Point`是结构体类型,通过`symbol->kind == TYPE`快速判断。

**`is_mutable`字段**:Rust 的可变性检查需要知道变量绑定是否可变。`let x`不可变,`let mut x`可变。这个信息要保存在符号中,赋值时检查。

**`members`字段**:模块和类型有自己的符号表。比如`std::io::stdin`,要先找到`std`模块,再在其 members 中找`io`,这是递归的符号表查找。

**`const_decl_node`字段**:常量求值需要。`const MAX: i32 = 100;`定义一个常量,后面使用`MAX`时,需要获取其定义的表达式`100`,进行编译期计算。

## 名称解析的执行流程

### 遍历策略:深度优先还是广度优先?

名称解析采用**深度优先遍历(DFS)**,这是必然的选择。因为:

1. 作用域是嵌套的树形结构,DFS 自然对应作用域的进入和退出
2. 要先定义后使用,DFS 保证按代码顺序处理
3. 递归函数调用栈天然维护作用域栈,实现简洁

### 访问表达式:查找还是绑定?

遇到`VariableExpr`(变量引用)时,名称解析器要做的是**查找并绑定**:

```cpp
shared_ptr<Symbol> NameResolutionVisitor::visit(VariableExpr *node) {
    // 1. 尝试在值命名空间查找
    auto symbol = symbol_table_.lookup_value(node->name.lexeme);

    // 2. 找不到,尝试类型命名空间(用于路径表达式)
    if (!symbol) {
        symbol = symbol_table_.lookup_type(node->name.lexeme);
    }

    // 3. 还是找不到,报错:未定义
    if (!symbol) {
        error_reporter_.report_error(
            "Undefined variable '" + node->name.lexeme + "'",
            node->name.line, node->name.column
        );
        return nullptr;
    }

    // 4. 找到了,绑定到AST节点
    node->resolved_symbol = symbol;
    return symbol;
}
```

这个过程看似简单,但蕴含深意:

**为什么先查值再查类型?**因为大多数情况下变量是值,这是常见情况优化。而且某些上下文(如路径表达式的前缀)可以是类型,所以要两个命名空间都查。

**为什么要绑定到 AST 节点?**因为后续的类型检查、代码生成都需要知道这个变量引用的是哪个定义。绑定后,整个 AST 成为了一个**带标注的语法树**,每个引用都知道自己指向谁。

**为什么返回 Symbol?**返回值供调用者使用,比如`PathExpr`需要知道左侧的类型,才能在其 members 中查找右侧。

### 访问 let 语句:定义的微妙之处

`let`语句是定义新符号的地方,处理起来比引用复杂:

```cpp
void NameResolutionVisitor::visit(LetStmt *node) {
    // 阶段1:解析类型注解(如果有)
    shared_ptr<Type> var_type = nullptr;
    if (node->type_annotation) {
        var_type = type_resolver_.resolve(node->type_annotation->get());
        if (!var_type) {
            error_reporter_.report_error("Cannot resolve type annotation.");
        }
    } else {
        error_reporter_.report_error("Variable declaration must have type annotation.");
    }

    // 阶段2:解析初始化表达式(如果有)
    if (node->initializer) {
        (*node->initializer)->accept(this);  // 递归解析
    }

    // 阶段3:处理模式,创建绑定
    current_type_ = var_type;   // 传递类型信息给模式
    node->pattern->accept(this);
    current_type_ = nullptr;
}
```

这里有几个关键设计决策:

**为什么先解析初始化器再处理模式?**因为 Rust 允许初始化器引用外层同名变量:

```rust
let x = 10;
let x = x + 1;  // 右边的x是外层的,左边的x是新定义
```

如果先定义新的`x`,右边的`x`就会绑定到未初始化的新符号,导致错误。

**为什么需要`current_type_`?**因为模式可能很复杂,如元组模式`let (a, b) = ...;`,要知道整体类型才能为`a`和`b`推导类型。通过临时变量传递类型信息,避免增加参数。

**为什么类型注解是必需的?**这是实现简化。完整的 Rust 编译器支持类型推导,但那需要复杂的约束求解。当前实现要求显式类型注解,大大简化了实现。

### 访问函数声明:两阶段定义

函数声明的处理分为两个阶段,这是为了支持**互相递归的函数**:

```rust
fn foo() { bar(); }  // foo调用bar
fn bar() { foo(); }  // bar调用foo
```

如果只有一遍扫描,`foo`中的`bar()`会报未定义错误,因为还没扫描到`bar`的定义。

解决方案是**两阶段**:

1. 第一阶段:只处理函数签名,创建符号,但不处理函数体
2. 第二阶段:处理函数体,这时所有函数符号都已定义

但当前实现采用了**简化的单遍**方案:先定义符号,再处理函数体,都在一次 visit 中完成:

```cpp
void NameResolutionVisitor::visit(FnDecl *node) {
    // 阶段1:解析参数类型,构建函数类型
    vector<shared_ptr<Type>> param_types;
    for (const auto &param : node->params) {
        auto param_type = type_resolver_.resolve(param->type.get());
        param_types.push_back(param_type);
    }

    shared_ptr<Type> return_type;
    if (node->return_type) {
        return_type = type_resolver_.resolve((*node->return_type).get());
    } else {
        return_type = make_shared<UnitType>();  // 无返回类型默认Unit
    }

    auto function_type = make_shared<FunctionType>(return_type, param_types);

    // 阶段2:创建函数符号,添加到符号表
    auto fn_symbol = make_shared<Symbol>(node->name.lexeme, Symbol::FUNCTION, function_type);
    if (!symbol_table_.define_value(node->name.lexeme, fn_symbol)) {
        error_reporter_.report_error("Function already defined.");
    }
    node->resolved_symbol = fn_symbol;

    // 阶段3:处理函数体(如果有)
    if (node->body) {
        symbol_table_.enter_scope();  // 新作用域

        // 为每个参数创建符号
        for (size_t i = 0; i < node->params.size(); ++i) {
            current_type_ = param_types[i];
            node->params[i]->pattern->accept(this);  // 处理参数模式
            current_type_ = nullptr;
        }

        (*node->body)->accept(this);  // 处理函数体

        symbol_table_.exit_scope();
    }
}
```

这个实现不支持相互递归的函数,但对于教学目的足够了。要支持相互递归,需要先遍历一遍收集所有函数签名,再遍历第二遍处理函数体。

### 访问结构体初始化:类型查找的应用

结构体初始化`Point { x: 1, y: 2 }`要验证`Point`是已定义的结构体类型:

```cpp
shared_ptr<Symbol> NameResolutionVisitor::visit(StructInitializerExpr *node) {
    // 1. 从表达式中提取类型名
    auto type_name_opt = get_name_from_expr(node->name.get());
    if (!type_name_opt) {
        error_reporter_.report_error("Invalid struct name.");
        return nullptr;
    }
    string type_name = *type_name_opt;

    // 2. 在类型命名空间查找
    auto struct_symbol = symbol_table_.lookup_type(type_name);
    if (!struct_symbol) {
        error_reporter_.report_error("Unknown type '" + type_name + "'.");
        return nullptr;
    }

    // 3. 验证是结构体类型
    if (struct_symbol->kind != Symbol::TYPE ||
        struct_symbol->type->kind != TypeKind::STRUCT) {
        error_reporter_.report_error("'" + type_name + "' is not a struct type.");
        return nullptr;
    }

    // 4. 绑定符号,供类型检查使用
    node->resolved_symbol = struct_symbol;

    // 5. 递归处理字段值
    for (auto &field : node->fields) {
        field->value->accept(this);
    }

    return nullptr;
}
```

这里展示了名称解析的一个重要模式:**先查找、再验证、后绑定**。不只是找到名字就完事,还要验证符号的种类是否符合预期。

### 路径表达式:递归查找

路径表达式`std::io::stdin`的解析是一个有趣的递归过程:

```cpp
shared_ptr<Symbol> NameResolutionVisitor::visit(PathExpr *node) {
    // 1. 递归解析左侧
    auto left_symbol = node->left->accept(this);
    if (!left_symbol) {
        return nullptr;  // 左侧解析失败,传播失败
    }

    // 2. 提取右侧的名字
    auto right_name_opt = get_name_from_expr(node->right.get());
    if (!right_name_opt) {
        error_reporter_.report_error("Invalid path component.");
        return nullptr;
    }
    string right_name = *right_name_opt;

    // 3. 在左侧符号的成员表中查找右侧
    if (!left_symbol->members) {
        error_reporter_.report_error("'" + left_symbol->name + "' has no members.");
        return nullptr;
    }

    auto final_symbol = left_symbol->members->lookup_value(right_name);
    if (!final_symbol) {
        error_reporter_.report_error("Member '" + right_name + "' not found.");
        return nullptr;
    }

    // 4. 绑定最终符号
    node->resolved_symbol = final_symbol;
    return final_symbol;
}
```

这里的巧妙之处在于**递归下降**:`std::io::stdin`被解析为`PathExpr(PathExpr(std, io), stdin)`,通过递归自然处理任意深度的路径。

每一步都返回 Symbol,下一步在该 Symbol 的 members 中查找。这种设计统一了模块访问、类型关联项访问、枚举变体访问等多种情况。

## 模式处理的特殊性

### 模式和表达式的二元性

模式(Pattern)在语法上类似表达式,但语义完全相反:

- **表达式**:计算一个值(读取)
- **模式**:绑定变量,接收一个值(写入)

比如`let (a, b) = (1, 2);`,右边`(1, 2)`是表达式,计算为元组值;左边`(a, b)`是模式,创建两个变量绑定。

名称解析处理模式时,要**创建新符号**而不是查找已有符号:

```cpp
void NameResolutionVisitor::visit(IdentifierPattern *node) {
    // 不查找,直接创建新符号
    auto var_symbol = make_shared<Symbol>(
        node->name.lexeme,
        Symbol::VARIABLE,
        current_type_  // 类型从上下文获取
    );
    var_symbol->is_mutable = node->is_mutable;

    // 添加到符号表,允许遮蔽
    symbol_table_.define_variable(node->name.lexeme, var_symbol, true);
    node->resolved_symbol = var_symbol;
}
```

注意`define_variable`的第三个参数`true`,表示**允许遮蔽**。这是 Rust 的特性,可以重新`let`同名变量。

### 引用模式的类型传播

引用模式`&x`或`&mut y`要求被绑定的值是引用类型,且要"剥掉"一层引用:

```rust
let r: &i32 = &42;
let &x = r;  // x的类型是i32,不是&i32
```

名称解析要传播正确的类型:

```cpp
void NameResolutionVisitor::visit(ReferencePattern *node) {
    // 1. 验证当前类型是引用类型
    auto *current_ref_type = dynamic_cast<ReferenceType *>(current_type_.get());
    if (!current_ref_type) {
        error_reporter_.report_error("Expected reference type in pattern.");
        return;
    }

    // 2. 检查可变性匹配
    if (node->is_mutable && !current_ref_type->is_mutable) {
        error_reporter_.report_error("Cannot bind immutable reference to mutable pattern.");
    }

    // 3. "剥掉"引用,传递内部类型
    auto inner_type = current_ref_type->referenced_type;
    auto original_type = current_type_;
    current_type_ = inner_type;

    // 4. 递归处理内部模式
    node->pattern->accept(this);

    // 5. 恢复原类型
    current_type_ = original_type;
}
```

这是一个经典的**类型向下传播**模式:父节点知道整体类型,子节点需要部分类型。通过临时修改`current_type_`,传递信息给子节点,处理完后恢复,避免污染后续处理。

## 作用域管理的时机

### 何时进入,何时退出?

作用域的生命周期必须精确匹配代码块的生命周期。一个常见错误是在错误的时机进入/退出作用域,导致符号可见性错误。

**块语句的作用域**:

```cpp
void NameResolutionVisitor::visit(BlockStmt *node) {
    symbol_table_.enter_scope();  // 进入前压栈

    // 处理所有语句
    for (auto &stmt : node->statements) {
        stmt->accept(this);
    }

    // 处理最终表达式(如果有)
    if (node->final_expr) {
        (*node->final_expr)->accept(this);
    }

    symbol_table_.exit_scope();  // 退出前弹栈
}
```

这里的关键是**对称性**:每个`enter_scope()`必须有对应的`exit_scope()`。使用 RAII(Resource Acquisition Is Initialization)模式可以避免忘记退出:

```cpp
class ScopeGuard {
    SymbolTable &table_;
public:
    ScopeGuard(SymbolTable &table) : table_(table) {
        table_.enter_scope();
    }
    ~ScopeGuard() {
        table_.exit_scope();
    }
};
```

但当前实现选择了显式调用,牺牲一点安全性换取代码的明确性。

**函数体的作用域**:

函数体创建新作用域,参数在这个作用域中可见:

```cpp
if (node->body) {
    symbol_table_.enter_scope();

    // 先定义参数
    for (auto &param : node->params) {
        // ... 处理参数模式,创建符号
    }

    // 再处理函数体
    (*node->body)->accept(this);

    symbol_table_.exit_scope();
}
```

注意顺序:参数必须在函数体前定义,因为函数体可以引用参数。

## 与类型解析的协作

### 为什么名称解析需要类型解析?

名称解析本身不关心类型的具体内容,但需要类型解析的原因是:**符号定义时要确定类型**。

考虑:

```rust
let x: Vec<i32> = ...;
```

创建`x`的符号时,要知道它的类型是`Vec<i32>`。但这个类型注解是一个 TypeNode,还不是真正的 Type 对象。必须调用类型解析,将`Vec<i32>`转换为类型对象,才能存入符号表。

这就是为什么 NameResolutionVisitor 持有 TypeResolver 的引用:

```cpp
class NameResolutionVisitor {
    TypeResolver &type_resolver_;  // 依赖注入
    // ...

    void visit(LetStmt *node) {
        if (node->type_annotation) {
            auto var_type = type_resolver_.resolve(node->type_annotation->get());
            // 使用var_type创建符号...
        }
    }
};
```

### 类型解析也需要名称解析

有趣的是,类型解析也需要名称解析,形成**循环依赖**:

- 名称解析需要类型解析:将类型注解转换为类型对象
- 类型解析需要名称解析:将类型名解析为类型定义

例如解析`Vec<i32>`时:

1. 类型解析看到`Vec`,要知道它是什么类型
2. 调用名称解析在符号表中查找`Vec`
3. 找到`Vec`的类型定义,获取其类型对象
4. 实例化泛型参数(简化版不支持真正的泛型,只是占位)

解决循环依赖的方法是**依赖注入**:

- TypeResolver 持有 NameResolutionVisitor 的引用
- NameResolutionVisitor 持有 TypeResolver 的引用
- 创建时相互传递引用,打破循环

## 错误处理的哲学

### 继续还是停止?

遇到未定义的名字时,有两种选择:

1. **立即停止**:报错并返回,不处理后续代码
2. **继续分析**:报错但继续,尽可能发现更多错误

当前实现选择**继续分析**:

```cpp
if (!symbol) {
    error_reporter_.report_error("Undefined variable ...");
    return nullptr;  // 返回空,但不停止整个分析
}
```

返回`nullptr`后,调用者要检查并优雅处理:

```cpp
auto left_symbol = node->left->accept(this);
if (!left_symbol) {
    return nullptr;  // 传播失败,避免级联错误
}
```

这种设计的好处是**一次编译发现多个错误**,用户不用反复编译-修复-编译。代价是要小心处理空指针,避免崩溃。

### 避免级联错误

一个错误可能导致大量后续误报,这叫**级联错误(Cascading Errors)**。例如:

```rust
let x: Foo = ...;  // Foo未定义
x.bar();           // x没有bar方法(因为x的类型未知)
let y = x;         // 类型不匹配(因为x的类型未知)
```

第一个错误是`Foo`未定义,后面的错误都是它的后果。好的编译器应该只报第一个错误。

避免级联错误的技巧:

1. **填充默认类型**:未定义的类型用 Unit 或 Unknown 类型代替
2. **提前返回**:遇到空符号立即返回,不继续推导
3. **标记错误节点**:记录哪些节点已报错,避免重复报告

当前实现主要使用技巧 2,返回`nullptr`后不继续处理,但这会丢失一些真实错误。更好的实现会使用技巧 1 和 3。

## 性能考虑

### 符号表查找的效率

符号表查找是名称解析的热点操作,每个变量引用都要查找一次。使用`unordered_map`(哈希表)保证了平均 O(1)的查找时间。

但作用域栈的查找是 O(d),d 是嵌套深度。对于大多数程序,d 很小(通常<10),所以不是瓶颈。如果需要优化,可以使用**缓存**:记住最近查找的符号,利用局部性原理。

### 智能指针的开销

大量使用`shared_ptr`会有性能开销:

- 引用计数的原子操作
- 间接访问(指针解引用)
- 内存碎片化(小对象分散分配)

但对于编译器前端,**正确性和可维护性远比性能重要**。手动内存管理容易出错,得不偿失。现代 C++推荐智能指针,编译器也不是性能瓶颈(相比代码生成和优化)。

## 总结

名称解析是语义分析的第一步,也是最基础的一步。它通过符号表建立了名字和定义的映射,为后续的类型检查、代码生成提供了必需的信息。

核心设计:

- **作用域栈**:自然处理嵌套和遮蔽
- **双命名空间**:值和类型分离,允许重名
- **深度优先遍历**:按代码顺序,匹配作用域生命周期
- **依赖注入**:与类型解析协作,打破循环依赖
- **错误恢复**:继续分析,发现更多错误

理解名称解析,就理解了编译器如何建立程序的"索引",将符号世界映射到语义世界。这是类型检查和代码生成的基石。
