# 常量求值器详解

## 编译期计算的必要性

为什么编译器需要执行代码?这看起来矛盾:**编译器生成可执行代码,而不是运行代码**。

但某些情况下,编译器**必须**求值表达式:

1. **数组大小**:`[i32; 10]` → `10`必须在编译期已知,才能分配内存
2. **常量定义**:`const MAX: i32 = 100;` → 常量的值要在编译期计算
3. **泛型参数**:`Array<i32, 10>` → 泛型参数可以是值,需要编译期求值
4. **条件编译**:`#[cfg(feature = "debug")]` → 特性检查需要求值

这些场景的共同点:**信息要在编译期确定,不能推迟到运行时**。

常量求值器就是编译器内置的"小解释器",在编译期执行表达式的计算,获取它们的值。

## 可求值表达式的范围

并非所有表达式都能在编译期求值。Rust 规定,常量表达式只能包含:

**允许的操作**:

- 字面量:`42`, `true`, `'a'`
- 算术运算:`+`, `-`, `*`, `/`, `%`
- 逻辑运算:`&&`, `||`, `!`
- 比较运算:`==`, `!=`, `<`, `>`, `<=`, `>=`
- 位运算:`&`, `|`, `^`, `<<`, `>>`
- 括号表达式:`(expr)`
- 常量引用:`MAX + 1`(如果`MAX`是常量)

**不允许的操作**:

- 变量引用:`let x = 10; const Y: i32 = x;` → `x`是变量,不能用于常量
- 函数调用:`const X: i32 = max(1, 2);` → 普通函数调用(除非是`const fn`)
- 控制流:`if`, `loop`, `match`(除非在`const fn`内)
- 堆分配:`Vec::new()`
- 引用解引用、字段访问等(有限支持)

当前实现支持**基础的算术和逻辑运算**,不支持控制流和复杂表达式。这对数组大小计算足够,但不能替代 Rust 的完整常量求值。

## 求值器的核心逻辑

### 递归求值策略

常量求值是**递归的**:复合表达式的值由子表达式的值组合而成。

例如`2 + 3 * 4`:

1. 求值左子表达式`2` → 2
2. 求值右子表达式`3 * 4`:
   - 求值`3` → 3
   - 求值`4` → 4
   - 计算`3 * 4` → 12
3. 计算`2 + 12` → 14

这是**后序遍历(Post-order Traversal)**:先求值子节点,再处理当前节点。

实现:

```cpp
optional<long long> ConstEvaluator::evaluate(Expr *node) {
    if (!node) {
        return nullopt;  // 空表达式,无法求值
    }

    // 根据表达式类型分发到不同的求值函数
    if (auto *lit = dynamic_cast<IntegerLiteralExpr *>(node)) {
        return evaluate_integer_literal(lit);
    } else if (auto *bin = dynamic_cast<BinaryExpr *>(node)) {
        return evaluate_binary_expr(bin);
    } else if (auto *unary = dynamic_cast<UnaryExpr *>(node)) {
        return evaluate_unary_expr(unary);
    } else if (auto *paren = dynamic_cast<ParenExpr *>(node)) {
        return evaluate(paren->expression.get());  // 递归求值
    } else if (auto *var = dynamic_cast<VariableExpr *>(node)) {
        return evaluate_variable(var);
    } else {
        // 其他类型的表达式不支持编译期求值
        error_reporter_.report_error("Expression is not a compile-time constant.");
        return nullopt;
    }
}
```

关键点:

- 返回`optional<long long>`:成功返回值,失败返回空
- 动态类型判断:根据 AST 节点类型选择处理逻辑
- 递归调用:`evaluate(child)`求值子表达式

### 值的表示:为何用 long long

常量求值的结果用什么类型表示?

选择`long long`(64 位有符号整数)的原因:

1. **足够大**:覆盖 Rust 的所有整数类型(i8 到 i64, u8 到 u64)
2. **有符号**:可以表示负数
3. **标准类型**:C++内置,不需要自定义大整数

但这有**局限性**:

- 无法精确表示 u64 的全部范围(2^63 到 2^64-1)
- 无法表示浮点数
- 无法表示复合值(元组、结构体等)

完整的实现需要**值对象**:

```cpp
class Value {
    enum Kind { INTEGER, FLOAT, BOOL, CHAR, TUPLE, STRUCT };
    Kind kind;
    union {
        long long int_val;
        double float_val;
        bool bool_val;
        char char_val;
    };
    // 或者用variant
};
```

当前简化为`long long`,对教学目的足够。

## 字面量的求值

字面量是最简单的常量:它们的值就是字面值。

### 整数字面量

整数字面量的求值要解析字符串为数值:

```cpp
optional<long long> ConstEvaluator::evaluate_integer_literal(IntegerLiteralExpr *node) {
    string literal = node->value;  // 如 "42", "0x1A", "0b1010"

    // 使用工具函数解析数值
    auto result = parse_integer_literal(literal);

    if (!result) {
        error_reporter_.report_error("Invalid integer literal: " + literal);
        return nullopt;
    }

    return *result;
}
```

`parse_integer_literal`处理:

- 十进制:`42` → 42
- 十六进制:`0x2A` → 42
- 二进制:`0b101010` → 42
- 八进制:`0o52` → 42
- 下划线分隔:`1_000` → 1000
- 类型后缀:`42i32` → 42(后缀在类型检查用,这里忽略)

解析逻辑在`tool/number.cpp`中,复用了词法分析器的代码。

### 布尔和字符字面量

布尔字面量更简单:

```cpp
optional<long long> ConstEvaluator::evaluate_bool_literal(BoolLiteralExpr *node) {
    return node->value ? 1 : 0;  // true → 1, false → 0
}
```

用 1/0 表示布尔值,运算时遵循 C 的语义:0 是假,非 0 是真。

字符字面量:

```cpp
optional<long long> ConstEvaluator::evaluate_char_literal(CharLiteralExpr *node) {
    // 'a' → 97 (ASCII码)
    return static_cast<long long>(node->value);
}
```

字符就是小整数,直接转换。

## 运算符的求值

### 二元运算符的分发

二元运算符种类繁多,需要分发到不同的处理逻辑:

```cpp
optional<long long> ConstEvaluator::evaluate_binary_expr(BinaryExpr *node) {
    // 1. 递归求值左右子表达式
    auto left_val = evaluate(node->left.get());
    auto right_val = evaluate(node->right.get());

    // 2. 如果任一子表达式求值失败,整体失败
    if (!left_val || !right_val) {
        return nullopt;
    }

    long long left = *left_val;
    long long right = *right_val;

    // 3. 根据运算符类型计算结果
    switch (node->op.type) {
        case TokenType::PLUS:
            return left + right;
        case TokenType::MINUS:
            return left - right;
        case TokenType::STAR:
            return left * right;
        case TokenType::SLASH:
            if (right == 0) {
                error_reporter_.report_error("Division by zero in constant expression.");
                return nullopt;
            }
            return left / right;
        case TokenType::PERCENT:
            if (right == 0) {
                error_reporter_.report_error("Modulo by zero in constant expression.");
                return nullopt;
            }
            return left % right;
        // ... 其他运算符
        default:
            error_reporter_.report_error("Operator not supported in constant expressions.");
            return nullopt;
    }
}
```

这体现了求值器的**解释器性质**:模拟运行时的语义,但在编译期执行。

关键细节:

- **短路求值**:当前实现**不支持**`&&`和`||`的短路,总是求值两边。正确的实现应该:
  ```cpp
  case TokenType::AND_AND:
      if (!left_val) return nullopt;
      if (*left_val == 0) return 0;  // 左侧为假,不求值右侧
      return evaluate(node->right.get());
  ```
- **除零检测**:编译期捕获除零错误,避免生成有问题的代码
- **溢出处理**:当前未检测溢出,`INT_MAX + 1`会默默溢出。完整实现应报错或警告

### 一元运算符的处理

一元运算符更简单:

```cpp
optional<long long> ConstEvaluator::evaluate_unary_expr(UnaryExpr *node) {
    auto operand_val = evaluate(node->operand.get());
    if (!operand_val) {
        return nullopt;
    }

    long long operand = *operand_val;

    switch (node->op.type) {
        case TokenType::MINUS:
            return -operand;
        case TokenType::BANG:
            return operand == 0 ? 1 : 0;  // 逻辑非
        case TokenType::TILDE:
            return ~operand;  // 按位取反
        default:
            error_reporter_.report_error("Unary operator not supported in constant expressions.");
            return nullopt;
    }
}
```

注意逻辑非的语义:`!0 = 1`, `!非0 = 0`。这和 C 一致。

### 比较运算符的布尔结果

比较运算符返回布尔值,但求值器用整数表示:

```cpp
case TokenType::LESS:
    return (left < right) ? 1 : 0;
case TokenType::LESS_EQUAL:
    return (left <= right) ? 1 : 0;
case TokenType::GREATER:
    return (left > right) ? 1 : 0;
case TokenType::GREATER_EQUAL:
    return (left >= right) ? 1 : 0;
case TokenType::EQUAL_EQUAL:
    return (left == right) ? 1 : 0;
case TokenType::NOT_EQUAL:
    return (left != right) ? 1 : 0;
```

这让布尔值可以参与算术运算:`(1 < 2) + 3 = 1 + 3 = 4`。虽然 Rust 禁止这种代码,但求值器内部允许,简化实现。

## 常量引用的求值

常量定义:`const MAX: i32 = 100;`

引用常量:`const SIZE: i32 = MAX + 1;`

求值器要支持查找常量的值:

```cpp
optional<long long> ConstEvaluator::evaluate_variable(VariableExpr *node) {
    // 1. 从符号表查找变量符号
    auto symbol = symbol_table_.lookup_value(node->name);

    if (!symbol) {
        error_reporter_.report_error("Undefined constant: " + node->name);
        return nullopt;
    }

    // 2. 验证是常量,不是变量
    if (!symbol->is_const) {
        error_reporter_.report_error(node->name + " is not a constant.");
        return nullopt;
    }

    // 3. 获取常量的初始化表达式
    if (!symbol->initializer) {
        error_reporter_.report_error("Constant " + node->name + " has no value.");
        return nullopt;
    }

    // 4. 递归求值初始化表达式
    return evaluate(symbol->initializer.get());
}
```

这里有个**重要问题**:循环依赖。

```rust
const A: i32 = B + 1;
const B: i32 = A + 1;
```

求值`A`需要求值`B`,求值`B`需要求值`A`,无限递归!

解决方案:**检测求值栈**:

```cpp
class ConstEvaluator {
    set<string> evaluating_;  // 正在求值的常量

    optional<long long> evaluate_variable(VariableExpr *node) {
        // 检测循环
        if (evaluating_.count(node->name)) {
            error_reporter_.report_error("Circular dependency in constant " + node->name);
            return nullopt;
        }

        // 标记正在求值
        evaluating_.insert(node->name);

        // 求值
        auto result = evaluate(symbol->initializer.get());

        // 移除标记
        evaluating_.erase(node->name);

        return result;
    }
};
```

这是**经典的循环检测**:维护"正在处理"的集合,检测重入。

当前实现**未实现这个检测**,会栈溢出,是个缺陷。

## 常量缓存和求值效率

每次引用常量都重新求值,效率低下:

```rust
const MAX: i32 = 100;
const SIZE: i32 = MAX + MAX + MAX;  // 求值MAX三次
```

优化:**缓存常量的值**:

```cpp
class ConstEvaluator {
    map<string, optional<long long>> const_cache_;

    optional<long long> evaluate_variable(VariableExpr *node) {
        // 1. 检查缓存
        if (const_cache_.count(node->name)) {
            return const_cache_[node->name];
        }

        // 2. 求值
        auto result = evaluate(symbol->initializer.get());

        // 3. 缓存结果
        const_cache_[node->name] = result;

        return result;
    }
};
```

这确保每个常量**只求值一次**,后续引用直接返回缓存值。

但要注意:**缓存和循环检测要协调**。如果正在求值的常量被缓存为"求值中",循环依赖检测失效。正确的设计:

```cpp
enum ConstState { NOT_EVALUATED, EVALUATING, EVALUATED };

struct ConstCacheEntry {
    ConstState state;
    optional<long long> value;
};

map<string, ConstCacheEntry> const_cache_;
```

用三态区分:未求值、求值中、已完成。

当前实现**未缓存**,每次重新计算。这对小程序影响不大,对大量常量会有性能问题。

## 位运算的语义

位运算在常量求值中很有用,但语义要小心:

```cpp
case TokenType::AMPERSAND:  // 按位与
    return left & right;
case TokenType::PIPE:  // 按位或
    return left | right;
case TokenType::CARET:  // 按位异或
    return left ^ right;
case TokenType::LEFT_SHIFT:  // 左移
    return left << right;
case TokenType::RIGHT_SHIFT:  // 右移
    return left >> right;
```

**陷阱 1:移位溢出**

```rust
const X: i32 = 1 << 100;  // 移位量超过位宽
```

C/C++中这是未定义行为!正确的实现应检查:

```cpp
if (right < 0 || right >= 64) {
    error_reporter_.report_error("Shift amount out of range.");
    return nullopt;
}
```

**陷阱 2:有符号右移**

C/C++的右移对有符号数是**实现定义**的:可以是算术右移(保持符号位)或逻辑右移(填充 0)。

Rust 明确规定:

- 有符号类型:`>>`是算术右移
- 无符号类型:`>>`是逻辑右移

当前实现用`long long`(有符号),右移是算术的。如果要支持无符号,需要:

```cpp
if (is_unsigned_type(node->left->type)) {
    unsigned long long uleft = static_cast<unsigned long long>(left);
    return static_cast<long long>(uleft >> right);
}
```

但这需要类型信息,而求值器当前是**类型无关**的。完整实现要携带类型。

## 错误处理和报告

常量求值的错误信息要精确:

```cpp
error_reporter_.report_error(
    "Constant expression evaluation failed at line " +
    to_string(node->location.line) +
    ": Division by zero"
);
```

位置信息帮助程序员定位问题。

但当前实现的错误报告**缺乏上下文**:

```rust
const SIZE: i32 = compute_size();  // 错误:函数调用
```

错误信息:"Expression is not a compile-time constant."

更好的错误:

```
Error: Constant expression cannot contain function calls
  --> example.rs:1:19
   |
1 | const SIZE: i32 = compute_size();
   |                   ^^^^^^^^^^^^^^
   |
   = note: Only compile-time constants and operators are allowed
```

这需要:

- 丰富的位置信息(行、列、文件)
- 上下文提示(为什么不允许)
- 建议(如何修复)

当前实现只有简单的错误消息,是可以改进的地方。

## 求值的限制和扩展

### 当前不支持的特性

1. **浮点运算**:`const PI: f64 = 3.14159;` → 需要`double`类型的值表示
2. **字符串操作**:`const MSG: &str = "Hello";` → 需要字符串对象
3. **数组/元组字面量**:`const ARR: [i32; 2] = [1, 2];` → 需要复合值
4. **控制流**:`const X: i32 = if true { 1 } else { 2 };` → 需要解释器逻辑
5. **函数调用**:`const Y: i32 = max(1, 2);` → 需要 const fn 的求值

### 扩展的方向

要支持完整的常量求值,需要:

**1. 通用值表示**

```cpp
class Value {
    shared_ptr<Type> type;
    variant<long long, double, bool, string, vector<Value>> data;
};
```

**2. 控制流解释**

```cpp
optional<Value> evaluate_if_expr(IfExpr *node) {
    auto cond = evaluate(node->condition.get());
    if (cond && is_true(cond)) {
        return evaluate(node->then_branch.get());
    } else if (node->else_branch) {
        return evaluate(node->else_branch->get());
    }
    return Value::unit();
}
```

**3. const fn 的内联**

遇到 const fn 调用,内联函数体并求值:

```cpp
optional<Value> evaluate_call(CallExpr *node) {
    auto *func = get_const_function(node->callee);
    if (!func) {
        return nullopt;  // 不是const fn
    }

    // 求值参数
    vector<Value> args;
    for (auto &arg : node->arguments) {
        auto val = evaluate(arg.get());
        if (!val) return nullopt;
        args.push_back(*val);
    }

    // 内联函数体,绑定参数,求值
    return inline_and_evaluate(func, args);
}
```

这些是高级特性,需要大量工作。当前实现专注于基础,满足数组大小计算的需求。

## 总结

常量求值器是**编译期的迷你解释器**,在编译时执行代码片段,获取它们的值。

核心机制:

- **递归求值**:后序遍历表达式树,组合子表达式的值
- **运算符模拟**:实现每个运算符的语义,处理边界情况(除零、溢出)
- **常量查找**:从符号表获取常量定义,递归求值初始化表达式
- **错误检测**:捕获编译期错误(除零、循环依赖),报告给用户
- **类型无关**:用通用的整数值表示,不依赖具体类型

限制和改进空间:

- 当前只支持整数运算,不支持浮点、字符串、复合值
- 缺乏循环依赖检测和常量缓存
- 错误信息简单,缺乏上下文
- 不支持控制流和函数调用

理解常量求值,就理解了编译器如何在编译期"执行"代码,如何跨越编译期和运行期的界限,如何给程序员提供编译期计算的能力。
