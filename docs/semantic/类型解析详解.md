# 类型解析器详解

## 类型解析的本质问题

编译器处理类型时面临一个基础问题:**程序员写的类型和编译器内部的类型表示是两种不同的东西**。

程序员写:`Vec<i32>`,这是**类型语法(Type Syntax)**,AST 中用`TypeNode`表示。
编译器需要:`VectorType{ element_type = i32_type }`,这是**类型对象(Type Object)**,用`Type`类及其子类表示。

类型解析就是这个转换过程:**从 TypeNode 到 Type 的映射**。看起来简单,实则复杂:

- `[i32; 10]`:数组大小`10`要计算求值
- `&mut T`:引用的可变性要记录
- `(i32, bool)`:元组的元素顺序要保持
- `MyStruct`:自定义类型要从符号表查找定义

更深层的问题:类型是**结构化的**。`Vec<Option<i32>>`包含三层类型:

1. 最外层:`Vec<T>`
2. 中间层:`Option<T>`
3. 最内层:`i32`

类型解析要递归处理这种嵌套结构,保持层次关系,正确传递信息。

## 类型系统的对象模型

### Type 类的继承层次

类型对象用面向对象的继承层次表示:

```
Type (抽象基类)
├── PrimitiveType: i32, bool, char等基础类型
├── UnitType: () 空元组类型
├── NeverType: ! 永不返回类型
├── ArrayType: [T; N] 固定大小数组
├── TupleType: (T1, T2, ...) 元组
├── ReferenceType: &T, &mut T 引用
├── RawPointerType: *const T, *mut T 裸指针
├── SliceType: &[T] 切片(未实现)
├── StructType: 结构体类型
├── EnumType: 枚举类型(未实现)
└── FunctionType: fn(T1, T2) -> R 函数类型
```

每个子类存储特定于该类型的信息:

- `ArrayType`:元素类型 + 数组大小
- `ReferenceType`:引用的类型 + 是否可变
- `FunctionType`:参数类型列表 + 返回类型

这种设计让类型信息**自包含**:一个`Type`对象完整描述了一个类型,不需要查询外部数据结构。

### TypeNode vs Type 的双重表示

为什么需要两套类型表示?

**TypeNode 是语法层的**:

- 对应源代码中的类型注解
- 包含位置信息(用于错误报告)
- 可能包含未解析的名字(`MyStruct`)
- 可能包含未计算的表达式(`[i32; N + 1]`)

**Type 是语义层的**:

- 对应类型系统的概念
- 不包含位置信息(节省内存)
- 只包含完全解析的信息
- 所有表达式已计算为值

类型解析就是跨越这个鸿沟:**把语法变成语义**。

## 基础类型的解析

基础类型的解析最简单,但仍有细节:

```cpp
shared_ptr<Type> TypeResolver::resolve(PrimitiveTypeNode *node) {
    // 直接映射TokenType到TypeKind
    switch (node->type_token.type) {
        case TokenType::KW_I32:
            return make_shared<PrimitiveType>(TypeKind::I32);
        case TokenType::KW_U32:
            return make_shared<PrimitiveType>(TypeKind::U32);
        case TokenType::KW_BOOL:
            return make_shared<PrimitiveType>(TypeKind::BOOL);
        // ... 其他类型
        default:
            error_reporter_.report_error("Unknown primitive type.");
            return nullptr;
    }
}
```

这看起来像是简单的枚举转换,但**语义比语法更稳定**。

如果以后想支持类型别名(`type MyInt = i32;`),语法层会出现新的`TypeNode`(别名名字),但解析后仍是`PrimitiveType(I32)`。这种分离让语法可以变化,而不影响类型系统的核心。

另一个好处是**类型对象可以共享**:所有`i32`类型注解解析为同一个`i32_type`对象(用单例或缓存实现),节省内存并加快类型比较(`ptr_a == ptr_b`)。

当前实现未优化,每次创建新对象,但预留了这个空间。

## 复合类型的递归解析

### 数组类型:嵌套+计算

数组类型`[T; N]`有两个参数:

- `T`:元素类型,需要递归解析
- `N`:数组大小,需要常量求值

```cpp
shared_ptr<Type> TypeResolver::resolve(ArrayTypeNode *node) {
    // 1. 递归解析元素类型
    shared_ptr<Type> element_type = resolve_type(node->element_type.get());
    if (!element_type) {
        return nullptr;  // 元素类型解析失败
    }

    // 2. 求值数组大小表达式
    ConstEvaluator const_evaluator(symbol_table_, error_reporter_);
    auto size_opt = const_evaluator.evaluate(node->size.get());

    if (!size_opt) {
        error_reporter_.report_error("Array size must be a constant.");
        return nullptr;
    }

    // 3. 验证大小有效性
    long long size_value = *size_opt;
    if (size_value < 0) {
        error_reporter_.report_error("Array size cannot be negative.");
        return nullptr;
    }

    // 4. 创建数组类型对象
    return make_shared<ArrayType>(element_type, static_cast<size_t>(size_value));
}
```

这个过程展示了类型解析的**组合性**:

- 先解析部分(元素类型)
- 再处理特殊逻辑(大小计算)
- 最后组合成整体(数组类型)

关键是错误处理:任何一步失败,返回`nullptr`,调用者会传播这个失败。

### 多层嵌套的处理

考虑`[[i32; 5]; 10]`:外层数组包含内层数组。

解析过程:

1. 解析外层`ArrayTypeNode`,元素类型是`ArrayTypeNode`
2. 递归解析内层`ArrayTypeNode`,元素类型是`PrimitiveTypeNode`
3. 内层返回`ArrayType{ element: i32, size: 5 }`
4. 外层返回`ArrayType{ element: ArrayType{...}, size: 10 }`

递归自然地处理了嵌套。但要注意**递归深度**:

```rust
type A = [A; 10];  // 递归类型定义
```

这会导致无限递归!Rust 禁止这种定义,编译器要检测。当前实现**未检测**,会栈溢出,是个缺陷。

完整实现需要:

- 维护"正在解析的类型"栈
- 检测循环依赖
- 报告友好的错误

### 元组类型:保持顺序

元组类型`(T1, T2, T3)`要解析多个元素类型,并保持顺序:

```cpp
shared_ptr<Type> TypeResolver::resolve(TupleTypeNode *node) {
    vector<shared_ptr<Type>> element_types;

    // 解析所有元素类型
    for (auto &element_node : node->element_types) {
        auto element_type = resolve_type(element_node.get());
        if (!element_type) {
            return nullptr;  // 任何一个失败都返回
        }
        element_types.push_back(element_type);
    }

    return make_shared<TupleType>(element_types);
}
```

这里的设计决策:**遇到第一个错误就停止解析**。

另一种策略是**继续解析**,收集所有错误。这需要:

```cpp
bool has_error = false;
for (auto &element_node : node->element_types) {
    auto element_type = resolve_type(element_node.get());
    if (!element_type) {
        has_error = true;
        element_types.push_back(make_shared<ErrorType>());  // 占位
    } else {
        element_types.push_back(element_type);
    }
}
if (has_error) return nullptr;
```

两种策略的权衡:

- 早停止:代码简单,但只报告第一个错误
- 继续解析:报告多个错误,但需要错误类型占位

当前实现选择简单,未来可优化。

## 引用类型的可变性

引用类型`&T`或`&mut T`除了引用的类型,还要记录**可变性**:

```cpp
shared_ptr<Type> TypeResolver::resolve(ReferenceTypeNode *node) {
    // 1. 解析被引用的类型
    shared_ptr<Type> referenced_type = resolve_type(node->inner_type.get());
    if (!referenced_type) {
        return nullptr;
    }

    // 2. 创建引用类型,包含可变性信息
    return make_shared<ReferenceType>(referenced_type, node->is_mutable);
}
```

`is_mutable`字段来自解析器:`&mut`设置为 true,`&`设置为 false。

这个信息至关重要:

- 类型检查时,判断是否可赋值
- 借用检查时,判断是否冲突(虽然当前未实现)
- 代码生成时,决定指令类型

**可变性是类型的一部分**:`&i32`和`&mut i32`是不同的类型,不能互换。这和 C++的`const`不同(C++的 const 是修饰符,不影响类型匹配)。

### 裸指针的区分

裸指针`*const T`和`*mut T`类似,但语义不同:

```cpp
shared_ptr<Type> TypeResolver::resolve(RawPointerTypeNode *node) {
    shared_ptr<Type> pointed_type = resolve_type(node->inner_type.get());
    if (!pointed_type) {
        return nullptr;
    }

    return make_shared<RawPointerType>(pointed_type, node->is_mutable);
}
```

裸指针和引用的区别:

- 裸指针可以是 null,引用不能
- 裸指针可以算术运算,引用不能
- 裸指针在`unsafe`块使用,引用是安全的

类型系统要区分两者,即使内部表示类似。这体现了**类型语义的重要性**:不只是内存布局,还有使用约束。

## 自定义类型的查找

### 路径表达式的解析

自定义类型用路径表达式表示:`MyStruct`或`module::MyEnum`。类型解析要:

1. 在符号表查找这个名字
2. 验证是类型符号(不是变量)
3. 获取类型对象

```cpp
shared_ptr<Type> TypeResolver::resolve(PathTypeNode *node) {
    // 1. 解析路径为符号
    shared_ptr<Symbol> symbol = resolve_path(node->segments);

    if (!symbol) {
        error_reporter_.report_error("Type not found: " + path_to_string(node->segments));
        return nullptr;
    }

    // 2. 验证是类型符号
    if (symbol->kind != Symbol::TYPE) {
        error_reporter_.report_error(path_to_string(node->segments) + " is not a type.");
        return nullptr;
    }

    // 3. 返回符号关联的类型
    return symbol->type;
}
```

关键是`resolve_path`函数,处理路径的段:

- 单段:`MyStruct` → 在当前作用域查找
- 多段:`mod::MyStruct` → 先找模块,再在模块内查找

当前实现**简化了模块**:假设所有类型在全局作用域,直接查找最后一段。完整实现需要模块系统。

### 类型符号的结构

类型符号(`Symbol::TYPE`)存储:

```cpp
struct Symbol {
    enum Kind { VARIABLE, TYPE, FUNCTION };
    Kind kind;
    string name;
    shared_ptr<Type> type;  // 对于TYPE,这是类型对象本身
    // ...
};
```

注意这里的`type`字段:

- 对于变量符号,`type`是变量的类型
- 对于类型符号,`type`是类型的定义

这有点绕:**类型符号的类型字段存储类型对象**。更清晰的设计是:

```cpp
struct TypeSymbol : Symbol {
    shared_ptr<Type> definition;  // 更明确的命名
};
```

但为了代码统一,用了同一个`type`字段。

## 函数类型的构造

函数类型`fn(T1, T2) -> R`需要解析:

- 参数类型列表
- 返回类型

```cpp
shared_ptr<Type> TypeResolver::resolve(FunctionTypeNode *node) {
    // 1. 解析所有参数类型
    vector<shared_ptr<Type>> param_types;
    for (auto &param_node : node->param_types) {
        auto param_type = resolve_type(param_node.get());
        if (!param_type) {
            return nullptr;
        }
        param_types.push_back(param_type);
    }

    // 2. 解析返回类型
    shared_ptr<Type> return_type;
    if (node->return_type) {
        return_type = resolve_type(node->return_type.get());
        if (!return_type) {
            return nullptr;
        }
    } else {
        // 无返回类型注解,默认是Unit
        return_type = make_shared<UnitType>();
    }

    // 3. 创建函数类型
    return make_shared<FunctionType>(param_types, return_type);
}
```

函数类型用于:

- 函数声明的签名
- 函数指针变量的类型
- 函数调用的类型检查

注意 Rust 的函数类型和函数项类型不同:

- 函数类型:`fn(i32) -> i32`,大小已知,可以存储
- 函数项类型:`typeof(my_function)`,每个函数独特,大小为 0

当前实现**未区分**两者,统一用`FunctionType`。这导致无法表达"某个特定函数"的类型,但对教学目的足够。

## 类型解析和名称解析的协作

类型解析依赖名称解析:**自定义类型需要从符号表查找**。但名称解析也依赖类型解析:**变量的类型注解需要解析**。

这是**循环依赖**。解决方案是**两阶段处理**:

**阶段 1:声明收集**

- 名称解析扫描所有类型定义,创建符号,但不解析类型体
- 此时类型符号的`type`字段是空的

**阶段 2:类型完成**

- 类型解析解析类型定义的体,填充`type`字段
- 现在可以查找类型符号,因为符号已存在

当前实现在`Semantic`类中协调:

```cpp
void Semantic::analyze() {
    // 第一遍:名称解析,声明收集
    NameResolver name_resolver(symbol_table_, error_reporter_);
    for (auto &item : ast_->items) {
        item->accept(&name_resolver);
    }

    // 第二遍:类型解析,完成类型定义
    TypeResolver type_resolver(symbol_table_, error_reporter_);
    for (auto &item : ast_->items) {
        // 解析struct定义、enum定义等
        type_resolver.complete_type_definition(item.get());
    }

    // 第三遍:类型检查
    TypeCheckVisitor type_checker(symbol_table_, type_resolver, error_reporter_);
    for (auto &item : ast_->items) {
        item->accept(&type_checker);
    }
}
```

这种**多遍扫描**是编译器的常见模式:每一遍处理特定层次的问题,按依赖顺序执行。

## 结构体类型的详细解析

结构体类型的解析比较复杂:

```cpp
shared_ptr<Type> TypeResolver::complete_struct_type(StructItemNode *node) {
    // 1. 创建结构体类型对象
    auto struct_type = make_shared<StructType>(node->name);

    // 2. 解析所有字段的类型
    for (auto &field : node->fields) {
        auto field_type = resolve_type(field.type_node.get());
        if (!field_type) {
            // 字段类型解析失败,但继续处理其他字段
            continue;
        }

        // 3. 添加字段到结构体
        struct_type->add_field(field.name, field_type, field.is_public);
    }

    // 4. 更新符号表中的类型符号
    auto symbol = symbol_table_.lookup_type(node->name);
    if (symbol) {
        symbol->type = struct_type;
    }

    return struct_type;
}
```

注意这里**即使某个字段类型解析失败,也继续处理其他字段**。这是错误恢复策略:尽可能收集信息,报告多个错误。

### 字段的可见性

每个字段有可见性信息:`pub field: i32`vs`field: i32`。类型解析要记录:

```cpp
struct StructField {
    string name;
    shared_ptr<Type> type;
    bool is_public;  // 可见性
};

class StructType : public Type {
    vector<StructField> fields;
};
```

这个信息用于:

- 类型检查字段访问:`obj.field`要检查可见性
- 模式匹配:`let MyStruct { field } = ...;`要检查字段是否可访问

### 方法的关联

结构体可以有关联方法:

```rust
impl MyStruct {
    fn new() -> MyStruct { ... }
}
```

方法要关联到结构体类型:

```cpp
class StructType : public Type {
    vector<StructField> fields;
    map<string, shared_ptr<FunctionType>> methods;  // 方法表
};
```

`impl`块的解析:

1. 查找目标类型(`MyStruct`)
2. 解析每个方法的签名
3. 添加到类型的方法表

调用方法时,从类型查找:`obj.method` → `obj.type->methods["method"]`。

当前实现**简化了 impl 块**:假设方法在定义时就添加到类型,未单独处理 impl。完整实现需要:

- 支持多个 impl 块
- 支持 trait impl
- 支持泛型 impl

## 错误处理和默认值

类型解析失败怎么办?返回`nullptr`是一种方式,但有问题:

```cpp
auto element_type = resolve_type(node->element_type.get());
if (!element_type) {
    return nullptr;  // 传播失败
}
```

这导致级联失败:一个类型解析失败,包含它的类型也失败,最终整个程序无法继续。

更好的策略是**错误类型(Error Type)**:

```cpp
class ErrorType : public Type {
    ErrorType() : Type(TypeKind::ERROR) {}
};

auto element_type = resolve_type(node->element_type.get());
if (!element_type) {
    element_type = make_shared<ErrorType>();  // 用错误类型占位
}
```

`ErrorType`的特殊性质:

- 和任何类型都兼容(避免级联错误)
- 不生成代码(跳过代码生成)
- 明确标记有错误的部分

这让编译器在错误后**继续分析**,发现更多问题,给程序员完整的错误列表。

当前实现未使用错误类型,导致一个类型错误后就停止。这是可以改进的地方。

## 类型缓存和共享

相同的类型注解解析为相同的类型对象吗?

不共享的实现:

```cpp
auto type1 = resolve_type(node1);  // 创建PrimitiveType(I32)
auto type2 = resolve_type(node2);  // 又创建一个PrimitiveType(I32)
// type1 != type2 (不同的对象)
```

共享的实现:

```cpp
class TypeResolver {
    map<string, shared_ptr<Type>> type_cache_;

    shared_ptr<Type> get_primitive_type(TypeKind kind) {
        string key = type_kind_to_string(kind);
        if (type_cache_.count(key)) {
            return type_cache_[key];
        }
        auto type = make_shared<PrimitiveType>(kind);
        type_cache_[key] = type;
        return type;
    }
};
```

共享的好处:

- 节省内存:只存储一份`i32`类型对象
- 加快比较:`type1.get() == type2.get()`直接比指针

但复杂类型的缓存键不好构造:`[i32; 10]`和`[[i32; 5]; 2]`的键是什么?

当前实现**未缓存**,每次创建新对象。这简化了代码,但浪费内存。优化时可考虑:

- 基础类型用单例
- 复杂类型用结构化哈希(递归哈希所有组件)

## 性能考量

类型解析的性能瓶颈:

1. **符号表查找**:每个自定义类型都要查符号表
2. **递归调用**:深层嵌套类型有很多递归
3. **内存分配**:每个类型对象都要分配内存

优化策略:

- 符号表用哈希表,查找 O(1)
- 类型缓存避免重复解析
- 内存池分配减少分配开销

但对于小到中型程序,这些优化不明显。教学编译器优先清晰性。

## 总结

类型解析是**语法到语义的桥梁**,将程序员写的类型注解转换为编译器能操作的类型对象。

核心机制:

- **递归解析**:处理嵌套类型结构
- **符号查找**:连接类型名字和类型定义
- **常量求值**:计算数组大小等编译期值
- **可变性记录**:保存引用和指针的可变性
- **错误处理**:优雅处理解析失败,避免级联错误

类型解析和名称解析、类型检查紧密协作:

- 名称解析提供符号表,类型解析查找类型符号
- 类型解析提供类型对象,类型检查验证类型约束

理解类型解析,就理解了编译器如何"理解"类型,如何在类型空间中导航,如何构建程序的类型结构。
